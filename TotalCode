/*
 * BioPrint AM - Unified Control System with PID Temperature Control
 * Arduino GIGA R1 WiFi
 * 
 * Features:
 * - Full UI with adjustable parameters
 * - PID P-only control (Kp=150) for heat mat temperature
 * - Temperature maintenance using thermistors A0, A1
 * - Automated extrusion control
 * - Emergency stop functionality
 * - Motor homing/reset capability
 * 
 * Hardware:
 * - Arduino GIGA R1 WiFi
 * - 2× 10K NTC thermistors (β=3435) on A0, A1 (heat mats)
 * - 2× 10K NTC thermistors (β=3950) on A2, A3 (system monitoring)
 * - MOSFET on Pin 9 (PWM heat control)
 * - 2× Tic stepper controllers (I2C addresses 14, 15)
 */

#include <Tic.h>
#include <Wire.h>
#include <math.h>
#include "Arduino_GigaDisplay_GFX.h"
#include "Arduino_GigaDisplayTouch.h"
#include <Fonts/FreeSansBold12pt7b.h>
#include <Fonts/FreeSans9pt7b.h>
#include <Fonts/FreeSansBold18pt7b.h>

// ==================== DISPLAY & TOUCH ====================
GigaDisplay_GFX display;
Arduino_GigaDisplayTouch touchDetector;

// Colors
#define BG_COLOR 0xFFFF
#define BUTTON_COLOR 0x0010
#define BUTTON_SELECTED_COLOR 0x4208
#define TEXT_COLOR 0x0010
#define BUTTON_TEXT_COLOR 0xFFFF
#define CONFIRM_COLOR 0xA9CF
#define CANCEL_COLOR 0xF800
#define CLEAR_COLOR 0xFD20

// ==================== MOTOR CONFIGURATION ====================
#define MOTOR1_ADDRESS 14
#define MOTOR2_ADDRESS 15

const float STEPS_PER_ML = 1000.0f;
const float MM_PER_STEP = 0.00605f;
const float MM_PER_ML = 6.05f;
const float MAX_VOLUME_ML = 12.0f;
const long LOAD_POSITION = 12000L;
const float MAX_SPEED_MMS = 3.0f;
const long MAX_SPEED_STEPS_S = 496L;
const int MAX_ACCEL = 1000;
const int POSITION_TOLERANCE = 10;

TicI2C tic1;
TicI2C tic2;

// ==================== HEAT CONTROL CONFIGURATION ====================
const int MOSFET_PIN = 9;  // PWM pin for heat control

// ==================== THERMISTOR CONFIGURATION ====================
// A0, A1: Heat mat thermistors (β=3435) - used for PID control
// A2, A3: System thermistors (β=3950) - monitoring only
const int numThermistors = 4;
const int thermistorPins[numThermistors] = {A0, A1, A2, A3};

// Thermistor constants for A0, A1 (heat mats)
const float seriesResistor_heat = 10000.0;
const float thermistorNominal_heat = 10000.0;
const float temperatureNominal_heat = 25.0;
const float betaCoefficient_heat = 3435.0;

// Thermistor constants for A2, A3 (system)
const float seriesResistor_sys = 10000.0;
const float thermistorNominal_sys = 10000.0;
const float temperatureNominal_sys = 25.0;
const float betaCoefficient_sys = 3950.0;

float currentTemperatures[numThermistors] = {-999, -999, -999, -999};
unsigned long lastTempUpdate = 0;
const unsigned long TEMP_UPDATE_INTERVAL = 1000;

// ==================== PID CONTROL PARAMETERS ====================
float Setpoint = 35.0;          // Target temperature (°C)
float Kp = 150.0;               // Proportional gain (FIXED)
float Input = 25.0;             // Average of A0 and A1
float Output = 0.0;             // PWM output (0-255)
bool heatControlEnabled = false;

// ==================== STATE MACHINE ====================
enum SystemState {
  UNINITIALIZED,
  LOAD,
  SETUP,
  PRIMED,
  READY,
  EXTRUDING,
  COMPLETE,
  SAFE_MODE
};

SystemState current_state = UNINITIALIZED;
const char* state_names[] = {"UNINITIALIZED", "LOAD", "SETUP", "PRIMED", "READY", "EXTRUDING", "COMPLETE", "SAFE_MODE"};

// ==================== UI PAGE DEFINITIONS ====================
enum Page {
  WELCOME,
  HOME,
  TEMPERATURE_PAGE,
  VOLUME1,
  VOLUME2,
  CONCENTRATION,
  SPEED,
  PRINT_CONFIRM,
  LOADING_PAGE,
  HOMING_PAGE,
  TEMP_READY,
  READY_TO_PRINT,
  PRINTING_PAGE,
  ERROR_PAGE
};

Page currentPage = WELCOME;

// Temperature stabilization tracking
float currentDisplayTemp = 25.0;  // Average of A2 and A3 for display
bool systemReady = false;
unsigned long tempStableTime = 0;
const unsigned long TEMP_STABLE_DURATION = 3000;  // 3 seconds stable
const float TEMP_TOLERANCE = 2.0;  // Within 2°C of target

// ==================== POSITION TRACKING ====================
long arduino_pos1 = 0;
long arduino_pos2 = 0;
bool motorsHomed = false;  // Track if motors have been homed

// Homing function - moves motors to max position then to zero
bool homeMotors() {
  Serial.println("\n=== HOMING MOTORS ===");
  
  // First, move to maximum position (LOAD_POSITION)
  Serial.println("Moving to maximum position...");
  if (!moveMotorsTo(LOAD_POSITION, LOAD_POSITION, MAX_SPEED_MMS)) {
    Serial.println("Failed to reach maximum position!");
    return false;
  }
  
  delay(500);
  
  // Then move to zero
  Serial.println("Moving to zero position...");
  if (!moveMotorsTo(0, 0, MAX_SPEED_MMS)) {
    Serial.println("Failed to reach zero position!");
    return false;
  }
  
  // Set zero as the reference
  arduino_pos1 = 0;
  arduino_pos2 = 0;
  
  tic1.haltAndSetPosition(0);
  tic2.haltAndSetPosition(0);
  
  motorsHomed = true;
  Serial.println("Homing complete! Motors at zero.");
  
  return true;
}

// ==================== SYSTEM CONFIGURATION ====================
struct SystemConfig {
  float ratio1 = 1.0f;
  float ratio2 = 1.0f;
  float syringe_vol1 = 10.0f;
  float syringe_vol2 = 10.0f;
  float extrude_vol1 = 1.0f;
  float extrude_speed = 2.0f;
  float dispensed1 = 0.0f;
  float dispensed2 = 0.0f;
  float remaining1 = 10.0f;
  float remaining2 = 10.0f;
  long prime_pos1 = LOAD_POSITION;
  long prime_pos2 = LOAD_POSITION;
} config;

// UI parameter storage
float selectedTemp = -1;
float selectedVol1 = -1;
float selectedVol2 = -1;
float selectedConc = -1;
float selectedSpeed = -1;
float tempSelection = -1;

// UI options
int tempOptions[] = {30, 32, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80};
int numTempOptions = 12;
int concOptions[] = {0, 25, 50, 75, 100};
int numConcOptions = 5;
int volOptions[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int numVolOptions = 10;
int speedOptions[] = {1, 2, 3, 4, 5};
int numSpeedOptions = 5;

bool lastTouchState = false;
bool isPrinting = false;

// ==================== UTILITY FUNCTIONS ====================
inline long mlToSteps(float ml) {
  return (long)(ml * STEPS_PER_ML);
}

inline float stepsToMl(long steps) {
  return (float)steps / STEPS_PER_ML;
}

inline long mmsToStepsPerSec(float mm_per_s) {
  long steps_s = (long)(mm_per_s / MM_PER_STEP);
  return constrain(steps_s, 1, MAX_SPEED_STEPS_S);
}

inline long stepsPerSecToTicUnits(long steps_per_sec) {
  return steps_per_sec * 10000L;
}

// ==================== THERMISTOR FUNCTIONS ====================
float readThermistor(int pin, bool isHeatMat) {
  int adcValue = analogRead(pin);
  
  if (adcValue <= 10 || adcValue >= 4095) {
    return -999.0;
  }
  
  // Select appropriate constants based on thermistor type
  float seriesR = isHeatMat ? seriesResistor_heat : seriesResistor_sys;
  float nominalR = isHeatMat ? thermistorNominal_heat : thermistorNominal_sys;
  float nominalT = isHeatMat ? temperatureNominal_heat : temperatureNominal_sys;
  float beta = isHeatMat ? betaCoefficient_heat : betaCoefficient_sys;
  
  // Convert ADC to resistance
  float voltageRatio = (4095.0 / adcValue) - 1.0;
  float resistance = seriesR / voltageRatio;
  
  // Steinhart-Hart equation
  float steinhart = resistance / nominalR;
  steinhart = log(steinhart);
  steinhart /= beta;
  steinhart += 1.0 / (nominalT + 273.15);
  steinhart = 1.0 / steinhart;
  steinhart -= 273.15;
  
  return steinhart;
}

void updateTemperatures() {
  // A0, A1: Heat mat sensors (β=3435)
  currentTemperatures[0] = readThermistor(thermistorPins[0], true);
  currentTemperatures[1] = readThermistor(thermistorPins[1], true);
  
  // A2, A3: System sensors (β=3950)
  currentTemperatures[2] = readThermistor(thermistorPins[2], false);
  currentTemperatures[3] = readThermistor(thermistorPins[3], false);
  
  // Calculate control temperature (average of A0 and A1) - for PID control
  if (currentTemperatures[0] > -999.0 && currentTemperatures[1] > -999.0) {
    Input = (currentTemperatures[0] + currentTemperatures[1]) / 2.0;
  } else if (currentTemperatures[0] > -999.0) {
    Input = currentTemperatures[0];
  } else if (currentTemperatures[1] > -999.0) {
    Input = currentTemperatures[1];
  } else {
    Input = -999.0;
  }
  
  // Calculate display temperature (average of A2 and A3) - for "Current Temperature" display
  if (currentTemperatures[2] > -999.0 && currentTemperatures[3] > -999.0) {
    currentDisplayTemp = (currentTemperatures[2] + currentTemperatures[3]) / 2.0;
  } else if (currentTemperatures[2] > -999.0) {
    currentDisplayTemp = currentTemperatures[2];
  } else if (currentTemperatures[3] > -999.0) {
    currentDisplayTemp = currentTemperatures[3];
  } else {
    currentDisplayTemp = -999.0;
  }
}

// ==================== PID CONTROL ====================
void computePControl() {
  if (!heatControlEnabled || Input < 0) {
    Output = 0;
    return;
  }
  
  // P-only control: Output = Kp × Error
  float error = Setpoint - Input;
  Output = Kp * error;
  
  // Constrain output to 0-255 (PWM range)
  Output = constrain(Output, 0, 255);
}

void applyHeatControl() {
  computePControl();
  
  if (heatControlEnabled && Input > 0) {
    analogWrite(MOSFET_PIN, (int)Output);
  } else {
    analogWrite(MOSFET_PIN, 0);
  }
}

// ==================== POSITION SYNCHRONIZATION ====================
bool syncPositionToTIC() {
  tic1.haltAndSetPosition(arduino_pos1);
  tic2.haltAndSetPosition(arduino_pos2);
  delay(20);
  
  long verify1 = tic1.getCurrentPosition();
  long verify2 = tic2.getCurrentPosition();
  
  if (abs(verify1 - arduino_pos1) > 5 || abs(verify2 - arduino_pos2) > 5) {
    Serial.println("ERROR: TIC position sync failed!");
    return false;
  }
  return true;
}

// ==================== MOTOR CONTROL ====================
void initializeMotors() {
  Wire.begin();
  delay(100);
  
  Serial.println("Initializing motors via I2C...");
  
  tic1.setAddress(MOTOR1_ADDRESS);
  delay(10);
  tic1.clearDriverError();
  tic1.energize();
  delay(10);
  tic1.exitSafeStart();
  delay(10);
  tic1.setMaxAccel(MAX_ACCEL * 100L);
  tic1.setMaxDecel(MAX_ACCEL * 100L);
  
  tic2.setAddress(MOTOR2_ADDRESS);
  delay(10);
  tic2.clearDriverError();
  tic2.energize();
  delay(10);
  tic2.exitSafeStart();
  delay(10);
  tic2.setMaxAccel(MAX_ACCEL * 100L);
  tic2.setMaxDecel(MAX_ACCEL * 100L);
  
  Serial.println("Motors initialized");
  
  // Read current TIC positions
  long init_pos1 = tic1.getCurrentPosition();
  long init_pos2 = tic2.getCurrentPosition();
  
  arduino_pos1 = init_pos1;
  arduino_pos2 = init_pos2;
  
  Serial.print("Current motor positions: M1=");
  Serial.print(init_pos1);
  Serial.print(", M2=");
  Serial.println(init_pos2);
  Serial.println("*** Please use HOME MOTORS button to calibrate ***");
}

bool moveMotorsTo(long target1, long target2, float speed_mms) {
  Serial.println("--- MOVEMENT ---");
  Serial.print("From: M1=");
  Serial.print(arduino_pos1);
  Serial.print(", M2=");
  Serial.println(arduino_pos2);
  Serial.print("To: M1=");
  Serial.print(target1);
  Serial.print(", M2=");
  Serial.println(target2);
  
  if (!syncPositionToTIC()) {
    Serial.println("Cannot move - position sync failed");
    current_state = SAFE_MODE;
    return false;
  }
  
  tic1.clearDriverError();
  tic2.clearDriverError();
  tic1.exitSafeStart();
  tic2.exitSafeStart();
  
  long speed_steps = mmsToStepsPerSec(speed_mms);
  tic1.setMaxSpeed(stepsPerSecToTicUnits(speed_steps));
  tic2.setMaxSpeed(stepsPerSecToTicUnits(speed_steps));
  
  tic1.setTargetPosition(target1);
  tic2.setTargetPosition(target2);
  
  unsigned long start_time = millis();
  
  while (true) {
    tic1.resetCommandTimeout();
    tic2.resetCommandTimeout();
    
    long pos1 = tic1.getCurrentPosition();
    long pos2 = tic2.getCurrentPosition();
    
    uint16_t err1 = tic1.getErrorStatus();
    uint16_t err2 = tic2.getErrorStatus();
    
    if (err1 != 0 || err2 != 0) {
      Serial.println("Motor error during movement!");
      arduino_pos1 = pos1;
      arduino_pos2 = pos2;
      current_state = SAFE_MODE;
      return false;
    }
    
    bool arrived1 = abs(pos1 - target1) <= POSITION_TOLERANCE;
    bool arrived2 = abs(pos2 - target2) <= POSITION_TOLERANCE;
    
    if (arrived1 && arrived2) {
      arduino_pos1 = target1;
      arduino_pos2 = target2;
      Serial.println("Movement complete");
      Serial.print("Final: M1=");
      Serial.print(arduino_pos1);
      Serial.print(", M2=");
      Serial.println(arduino_pos2);
      return true;
    }
    
    if (millis() - start_time > 30000) {
      Serial.println("Movement timeout!");
      arduino_pos1 = pos1;
      arduino_pos2 = pos2;
      return false;
    }
    
    delay(10);
  }
}

// ==================== STATE MACHINE FUNCTIONS ====================
bool executeLoad() {
  Serial.println("\n=== LOAD SEQUENCE ===");
  current_state = LOAD;
  
  if (!moveMotorsTo(LOAD_POSITION, LOAD_POSITION, MAX_SPEED_MMS)) {
    Serial.println("Load failed!");
    current_state = SAFE_MODE;
    return false;
  }
  
  Serial.println("Load complete - syringes at top");
  return true;
}

bool executeSetup(float vol1, float vol2, float concentration) {
  Serial.println("\n=== SETUP SEQUENCE ===");
  current_state = SETUP;
  
  config.syringe_vol1 = vol1;
  config.syringe_vol2 = vol2;
  
  float total_vol = vol1 + vol2;
  config.ratio1 = vol1 / total_vol;
  config.ratio2 = vol2 / total_vol;
  
  Serial.print("Volumes: M1=");
  Serial.print(config.syringe_vol1);
  Serial.print(" mL, M2=");
  Serial.print(config.syringe_vol2);
  Serial.println(" mL");
  Serial.print("Ratios: M1=");
  Serial.print(config.ratio1);
  Serial.print(", M2=");
  Serial.println(config.ratio2);
  
  config.remaining1 = config.syringe_vol1;
  config.remaining2 = config.syringe_vol2;
  config.dispensed1 = 0.0f;
  config.dispensed2 = 0.0f;
  
  return true;
}

bool executePrime() {
  Serial.println("\n=== PRIME SEQUENCE ===");
  current_state = PRIMED;
  
  config.prime_pos1 = arduino_pos1;
  config.prime_pos2 = arduino_pos2;
  
  Serial.print("Prime positions set: M1=");
  Serial.print(config.prime_pos1);
  Serial.print(", M2=");
  Serial.println(config.prime_pos2);
  
  return true;
}

bool executeExtrude(float volume_ml, float speed_mms) {
  Serial.println("\n=== EXTRUDE ===");
  Serial.print("Volume: ");
  Serial.print(volume_ml);
  Serial.print(" mL at ");
  Serial.print(speed_mms);
  Serial.println(" mm/s");
  
  current_state = EXTRUDING;
  
  float vol1_to_dispense = volume_ml * config.ratio1;
  float vol2_to_dispense = volume_ml * config.ratio2;
  
  if (vol1_to_dispense > config.remaining1 || vol2_to_dispense > config.remaining2) {
    Serial.println("ERROR: Not enough material remaining!");
    Serial.print("Need M1: ");
    Serial.print(vol1_to_dispense);
    Serial.print(" mL, Have: ");
    Serial.print(config.remaining1);
    Serial.println(" mL");
    Serial.print("Need M2: ");
    Serial.print(vol2_to_dispense);
    Serial.print(" mL, Have: ");
    Serial.print(config.remaining2);
    Serial.println(" mL");
    current_state = COMPLETE;
    return false;
  }
  
  long steps1 = mlToSteps(vol1_to_dispense);
  long steps2 = mlToSteps(vol2_to_dispense);
  
  long target1 = arduino_pos1 - steps1;
  long target2 = arduino_pos2 - steps2;
  
  if (!moveMotorsTo(target1, target2, speed_mms)) {
    Serial.println("Extrusion movement failed!");
    current_state = SAFE_MODE;
    return false;
  }
  
  config.dispensed1 += vol1_to_dispense;
  config.dispensed2 += vol2_to_dispense;
  config.remaining1 -= vol1_to_dispense;
  config.remaining2 -= vol2_to_dispense;
  
  Serial.print("Dispensed: M1=");
  Serial.print(config.dispensed1);
  Serial.print(" mL, M2=");
  Serial.print(config.dispensed2);
  Serial.println(" mL");
  Serial.print("Remaining: M1=");
  Serial.print(config.remaining1);
  Serial.print(" mL, M2=");
  Serial.print(config.remaining2);
  Serial.println(" mL");
  
  return true;
}

// ==================== UI DRAWING FUNCTIONS ====================
void drawWelcomePage() {
  display.fillScreen(BG_COLOR);
  display.setFont(&FreeSansBold18pt7b);
  display.setTextColor(TEXT_COLOR);
  
  display.setCursor(80, 200);
  display.print("BioPrint AM");
  
  display.setFont(&FreeSans9pt7b);
  display.setCursor(120, 300);
  display.print("v3.0 + PID");
  
  display.setCursor(70, 400);
  display.print("Temperature Control");
  
  // Temperature display
  display.setCursor(80, 480);
  display.print("Heat Mats:");
  display.setCursor(80, 510);
  display.print("A0: ");
  display.print(currentTemperatures[0], 1);
  display.print(" C  A1: ");
  display.print(currentTemperatures[1], 1);
  display.print(" C");
  
  // Homing status
  display.setCursor(80, 560);
  if (motorsHomed) {
    display.setTextColor(CONFIRM_COLOR);
    display.print("Motors: HOMED");
  } else {
    display.setTextColor(CANCEL_COLOR);
    display.print("Motors: NOT HOMED!");
  }
  
  // HOME MOTORS button (orange)
  display.fillRoundRect(90, 600, 300, 70, 10, CLEAR_COLOR);
  display.setFont(&FreeSansBold12pt7b);
  display.setTextColor(BUTTON_TEXT_COLOR);
  display.setCursor(130, 645);
  display.print("HOME MOTORS");
  
  // START button
  display.setTextColor(TEXT_COLOR);
  display.fillRoundRect(140, 700, 200, 70, 10, BUTTON_COLOR);
  display.setTextColor(BUTTON_TEXT_COLOR);
  display.setCursor(185, 745);
  display.print("START");
}

void drawHomingPage() {
  display.fillScreen(BG_COLOR);
  display.setFont(&FreeSansBold18pt7b);
  display.setTextColor(TEXT_COLOR);
  display.setCursor(100, 200);
  display.print("HOMING...");
  
  display.setFont(&FreeSans9pt7b);
  display.setCursor(80, 300);
  display.print("Moving motors to");
  display.setCursor(80, 330);
  display.print("maximum then zero");
  
  display.setCursor(80, 400);
  display.print("Please wait...");
  
  // Current positions
  display.setCursor(80, 500);
  display.print("M1: ");
  display.print(arduino_pos1);
  display.print(" steps");
  display.setCursor(80, 530);
  display.print("M2: ");
  display.print(arduino_pos2);
  display.print(" steps");
}

void drawHomePage() {
  display.fillScreen(BG_COLOR);
  display.setTextColor(TEXT_COLOR);
  display.setFont(&FreeSansBold12pt7b);
  display.setCursor(35, 50);
  display.print("PARAMETER CONTROL");
  
  // Draw parameter buttons vertically stacked - portrait 480x800
  drawHomeButton(40, 120, "Temperature", selectedTemp, "C");
  drawHomeButton(40, 230, "Volume 1", selectedVol1, "mL");
  drawHomeButton(40, 340, "Volume 2", selectedVol2, "mL");
  drawHomeButton(40, 450, "Concentration", selectedConc, "%");
  drawHomeButton(40, 560, "Speed", selectedSpeed, "mm/s");
  
  // Draw PRINT button at bottom
  display.fillRoundRect(140, 690, 200, 80, 8, CONFIRM_COLOR);
  display.setFont(&FreeSansBold18pt7b);
  display.setTextColor(TEXT_COLOR);
  display.setCursor(185, 740);
  display.print("PRINT");
}

void drawHomeButton(int x, int y, const char* label, float value, const char* unit) {
  // Draw button
  display.fillRoundRect(x, y, 400, 90, 8, BUTTON_COLOR);
  
  // Label with bold font
  display.setFont(&FreeSansBold12pt7b);
  display.setTextColor(BUTTON_TEXT_COLOR);
  display.setCursor(x + 15, y + 30);
  display.print(label);
  
  // Status with regular font
  display.setFont(&FreeSans9pt7b);
  display.setCursor(x + 15, y + 65);
  if (value < 0) {
    display.print("Not Selected");
  } else {
    display.print("Selected: ");
    
    // Special formatting for concentration
    if (unit[0] == '%') {
      float inverse = 100 - value;
      display.print(value, 1);
      display.print(":");
      display.print(inverse, 1);
      display.print("%");
    } else {
      display.print(value, 1);
      display.print(" ");
      if (unit[0] == 'C') {
        display.write(248); // Degree symbol
      }
      display.print(unit);
    }
  }
}

void drawParameterPage(int* options, int numOptions, float currentValue, const char* title, const char* unit) {
  display.fillScreen(BG_COLOR);
  display.setTextColor(TEXT_COLOR);
  display.setFont(&FreeSansBold12pt7b);
  display.setCursor(50, 40);
  display.print("Select ");
  display.print(title);
  display.print(":");
  
  // Draw white display box showing current selection with +/- buttons
  int boxX = 40;
  int boxY = 75;
  int boxWidth = 260;
  int boxHeight = 100;
  int buttonSize = 70;
  int buttonSpacing = 10;
  
  // Draw - button (left)
  display.fillRoundRect(boxX, boxY, buttonSize, boxHeight, 8, CONFIRM_COLOR);
  display.setFont(&FreeSansBold18pt7b);
  display.setTextColor(BUTTON_TEXT_COLOR);
  display.setCursor(boxX + 28, boxY + 62);
  display.print("-");
  
  // Draw display box (center)
  display.fillRoundRect(boxX + buttonSize + buttonSpacing, boxY, boxWidth, boxHeight, 8, BUTTON_COLOR);
  display.setFont(&FreeSansBold18pt7b);
  display.setTextColor(BUTTON_TEXT_COLOR);
  
  // Display current selection in the box
  if (tempSelection < 0) {
    display.setCursor(boxX + buttonSize + buttonSpacing + 45, boxY + 62);
    display.print("Not Set");
  } else {
    String valueStr = "";
    
    // Special formatting for concentration
    if (unit[0] == '%') {
      float inverse = 100 - tempSelection;
      valueStr = String(tempSelection, 1) + ":" + String(inverse, 1) + "%";
      int charCount = valueStr.length();
      int textWidth = charCount * 18;
      int textX = boxX + buttonSize + buttonSpacing + (boxWidth / 2) - (textWidth / 2);
      display.setCursor(textX, boxY + 62);
      display.print(valueStr);
    } else if (unit[0] == 'C') {
      int charCount = String(tempSelection, 1).length() + 2;
      int textWidth = charCount * 18;
      int textX = boxX + buttonSize + buttonSpacing + (boxWidth / 2) - (textWidth / 2);
      display.setCursor(textX, boxY + 62);
      display.print(tempSelection, 1);
      display.print(" ");
      display.write(248); // Degree symbol
      display.print(unit);
    } else {
      valueStr = String(tempSelection, 1) + " " + unit;
      int charCount = valueStr.length();
      int textWidth = charCount * 18;
      int textX = boxX + buttonSize + buttonSpacing + (boxWidth / 2) - (textWidth / 2);
      display.setCursor(textX, boxY + 62);
      display.print(valueStr);
    }
  }
  
  // Draw + button (right)
  display.fillRoundRect(boxX + buttonSize + buttonSpacing + boxWidth + buttonSpacing, boxY, buttonSize, boxHeight, 8, CONFIRM_COLOR);
  display.setFont(&FreeSansBold18pt7b);
  display.setTextColor(BUTTON_TEXT_COLOR);
  display.setCursor(boxX + buttonSize + buttonSpacing + boxWidth + buttonSpacing + 24, boxY + 62);
  display.print("+");
  
  // Draw option buttons - 3 columns for portrait
  int cols = 3;
  int buttonWidth = 120;
  int buttonHeight = 80;
  int spacingX = 20;
  int spacingY = 20;
  int startX = 40;
  int startY = 200;
  
  for (int i = 0; i < numOptions; i++) {
    int row = i / cols;
    int col = i % cols;
    int bx = startX + col * (buttonWidth + spacingX);
    int by = startY + row * (buttonHeight + spacingY);
    
    bool isSelected = (abs(options[i] - tempSelection) < 0.01);
    uint16_t bgColor = isSelected ? BUTTON_SELECTED_COLOR : BUTTON_COLOR;
    
    display.fillRoundRect(bx, by, buttonWidth, buttonHeight, 8, bgColor);
    display.setFont(&FreeSansBold18pt7b);
    display.setTextColor(BUTTON_TEXT_COLOR);
    
    // Center text in button
    String valueStr = String(options[i]);
    int charCount = valueStr.length();
    int textWidth = charCount * 20;
    int textX = bx + (buttonWidth - textWidth) / 2;
    int textY = by + 52;
    
    display.setCursor(textX, textY);
    display.print(options[i]);
  }
  
  // Draw clear button above confirm button
  display.fillRoundRect(170, 630, 140, 50, 8, CLEAR_COLOR);
  display.setFont(&FreeSansBold12pt7b);
  display.setTextColor(BUTTON_TEXT_COLOR);
  display.setCursor(195, 663);
  display.print("CLEAR");
  
  // Draw confirm button at bottom center
  display.fillRoundRect(140, 700, 200, 70, 8, CONFIRM_COLOR);
  display.setFont(&FreeSansBold12pt7b);
  display.setTextColor(BUTTON_TEXT_COLOR);
  display.setCursor(170, 745);
  display.print("CONFIRM");
}

void drawPrintConfirmPage() {
  display.fillScreen(BG_COLOR);
  display.setTextColor(TEXT_COLOR);
  display.setFont(&FreeSansBold18pt7b);
  display.setCursor(80, 50);
  display.print("Begin Loading?");
  
  // Draw parameter summary with bigger font
  int yPos = 130;
  int lineHeight = 90;
  
  // Temperature
  drawParameterSummary(40, yPos, "Temperature:", selectedTemp, "C");
  yPos += lineHeight;
  
  // Volume 1
  drawParameterSummary(40, yPos, "Volume 1:", selectedVol1, "mL");
  yPos += lineHeight;
  
  // Volume 2
  drawParameterSummary(40, yPos, "Volume 2:", selectedVol2, "mL");
  yPos += lineHeight;
  
  // Concentration
  drawParameterSummary(40, yPos, "Concentration:", selectedConc, "%");
  yPos += lineHeight;
  
  // Speed
  drawParameterSummary(40, yPos, "Speed:", selectedSpeed, "mm/s");
  
  // Draw CONFIRM button
  display.fillRoundRect(60, 650, 160, 80, 8, CONFIRM_COLOR);
  display.setFont(&FreeSansBold12pt7b);
  display.setTextColor(BUTTON_TEXT_COLOR);
  display.setCursor(85, 700);
  display.print("CONFIRM");
  
  // Draw CANCEL button
  display.fillRoundRect(260, 650, 160, 80, 8, CANCEL_COLOR);
  display.setFont(&FreeSansBold12pt7b);
  display.setTextColor(BUTTON_TEXT_COLOR);
  display.setCursor(295, 700);
  display.print("CANCEL");
}

void drawParameterSummary(int x, int y, const char* label, float value, const char* unit) {
  display.setFont(&FreeSansBold12pt7b);
  display.setTextColor(TEXT_COLOR);
  display.setCursor(x, y);
  display.print(label);
  
  display.setFont(&FreeSansBold12pt7b);
  display.setCursor(x, y + 40);
  if (value < 0) {
    display.print("Not Selected");
  } else {
    // Special formatting for concentration
    if (unit[0] == '%') {
      float inverse = 100 - value;
      display.print(value, 1);
      display.print(":");
      display.print(inverse, 1);
      display.print("%");
    } else {
      display.print(value, 1);
      display.print(" ");
      if (unit[0] == 'C') {
        display.write(248); // Degree symbol
      }
      display.print(unit);
    }
  }
}

void drawLoadingPage() {
  display.fillScreen(BG_COLOR);
  display.setFont(&FreeSansBold18pt7b);
  display.setTextColor(TEXT_COLOR);
  display.setCursor(80, 150);
  display.print("LOADING...");
  
  display.setFont(&FreeSans9pt7b);
  
  // Current Temperature (A2/A3 average)
  display.setCursor(50, 220);
  display.print("Current Temperature:");
  display.setFont(&FreeSansBold12pt7b);
  display.setCursor(50, 260);
  if (currentDisplayTemp > -999.0) {
    display.print(currentDisplayTemp, 1);
    display.print(" C");
  } else {
    display.print("--- C");
  }
  
  // Selected Temperature
  display.setFont(&FreeSans9pt7b);
  display.setCursor(50, 310);
  display.print("Selected Temperature:");
  display.setFont(&FreeSansBold12pt7b);
  display.setCursor(50, 350);
  display.print(Setpoint, 1);
  display.print(" C");
  
  // Heat Mat Details
  display.setFont(&FreeSans9pt7b);
  display.setCursor(50, 410);
  display.print("Heat Mat Temps (A0, A1):");
  display.setCursor(50, 440);
  display.print("A0: ");
  display.print(currentTemperatures[0], 1);
  display.print(" C  A1: ");
  display.print(currentTemperatures[1], 1);
  display.print(" C");
  
  display.setCursor(50, 480);
  display.print("Heat Output: ");
  display.print((Output / 255.0) * 100.0, 1);
  display.print(" %");
  
  // System temps
  display.setCursor(50, 530);
  display.print("System Temps (A2, A3):");
  display.setCursor(50, 560);
  display.print("A2: ");
  display.print(currentTemperatures[2], 1);
  display.print(" C  A3: ");
  display.print(currentTemperatures[3], 1);
  display.print(" C");
  
  display.setCursor(120, 620);
  display.print(state_names[current_state]);
  
  // Home button
  display.fillRoundRect(140, 680, 200, 80, 10, CANCEL_COLOR);
  display.setTextColor(BUTTON_TEXT_COLOR);
  display.setCursor(185, 730);
  display.print("HOME");
}

void drawTempReadyPage() {
  display.fillScreen(BG_COLOR);
  display.setFont(&FreeSansBold18pt7b);
  display.setTextColor(TEXT_COLOR);
  display.setCursor(80, 120);
  display.print("READY?");
  
  display.setFont(&FreeSans9pt7b);
  
  // Current Temperature (A2/A3 average)
  display.setCursor(50, 200);
  display.print("Current Temperature:");
  display.setFont(&FreeSansBold12pt7b);
  display.setCursor(50, 240);
  if (currentDisplayTemp > -999.0) {
    display.print(currentDisplayTemp, 1);
    display.print(" C");
  } else {
    display.print("--- C");
  }
  
  // Selected Temperature
  display.setFont(&FreeSans9pt7b);
  display.setCursor(50, 290);
  display.print("Selected Temperature:");
  display.setFont(&FreeSansBold12pt7b);
  display.setCursor(50, 330);
  display.print(Setpoint, 1);
  display.print(" C");
  
  // Status message
  display.setFont(&FreeSans9pt7b);
  display.setCursor(50, 390);
  
  if (systemReady) {
    display.setTextColor(CONFIRM_COLOR);
    display.print("Temperature reached!");
    display.setTextColor(TEXT_COLOR);
    display.setCursor(50, 420);
    display.print("Actuators initialized");
    display.setCursor(50, 450);
    display.print("Motors homed");
  } else {
    display.print("Waiting for:");
    int yPos = 420;
    if (abs(currentDisplayTemp - Setpoint) > TEMP_TOLERANCE) {
      display.setCursor(50, yPos);
      display.print("- Temperature stabilization");
      yPos += 30;
    }
    if (current_state != PRIMED) {
      display.setCursor(50, yPos);
      display.print("- Actuator initialization");
      yPos += 30;
    }
    if (!motorsHomed) {
      display.setCursor(50, yPos);
      display.setTextColor(CANCEL_COLOR);
      display.print("- MOTOR HOMING REQUIRED!");
      display.setTextColor(TEXT_COLOR);
      display.setCursor(50, yPos + 25);
      display.print("  (Press HOME on welcome page)");
    }
  }
  
  // System details
  display.setCursor(50, 510);
  display.print("Heat Mats: A0=");
  display.print(currentTemperatures[0], 1);
  display.print(" A1=");
  display.print(currentTemperatures[1], 1);
  
  display.setCursor(50, 540);
  display.print("System: A2=");
  display.print(currentTemperatures[2], 1);
  display.print(" A3=");
  display.print(currentTemperatures[3], 1);
  
  // YES button (only if ready)
  if (systemReady) {
    display.fillRoundRect(90, 600, 300, 80, 10, CONFIRM_COLOR);
    display.setFont(&FreeSansBold18pt7b);
    display.setTextColor(BUTTON_TEXT_COLOR);
    display.setCursor(180, 655);
    display.print("YES");
  }
  
  // HOME button
  display.setFont(&FreeSans9pt7b);
  display.fillRoundRect(140, 700, 200, 60, 10, CANCEL_COLOR);
  display.setTextColor(BUTTON_TEXT_COLOR);
  display.setCursor(190, 740);
  display.print("HOME");
}

void drawReadyToPrintPage() {
  display.fillScreen(BG_COLOR);
  display.setFont(&FreeSansBold18pt7b);
  display.setTextColor(TEXT_COLOR);
  display.setCursor(60, 100);
  display.print("READY!");
  
  display.setFont(&FreeSans9pt7b);
  
  // Temperature info
  display.setCursor(50, 180);
  display.print("Temperature: ");
  display.print(Input, 1);
  display.print(" / ");
  display.print(Setpoint, 0);
  display.print(" C");
  
  // Volume info
  display.setCursor(50, 230);
  display.print("Remaining:");
  display.setCursor(50, 260);
  display.print("M1: ");
  display.print(config.remaining1, 2);
  display.print(" mL");
  display.setCursor(50, 290);
  display.print("M2: ");
  display.print(config.remaining2, 2);
  display.print(" mL");
  
  display.setCursor(50, 340);
  display.print("Dispensed:");
  display.setCursor(50, 370);
  display.print("M1: ");
  display.print(config.dispensed1, 2);
  display.print(" mL");
  display.setCursor(50, 400);
  display.print("M2: ");
  display.print(config.dispensed2, 2);
  display.print(" mL");
  
  // PRINT button
  display.fillRoundRect(90, 500, 300, 120, 10, CONFIRM_COLOR);
  display.setFont(&FreeSansBold18pt7b);
  display.setTextColor(BUTTON_TEXT_COLOR);
  display.setCursor(155, 575);
  display.print("PRINT");
  
  // HOME button
  display.setFont(&FreeSans9pt7b);
  display.fillRoundRect(140, 670, 200, 70, 10, CANCEL_COLOR);
  display.setCursor(190, 715);
  display.print("HOME");
}

void drawPrintingPage() {
  display.fillScreen(BG_COLOR);
  display.setFont(&FreeSansBold18pt7b);
  display.setTextColor(TEXT_COLOR);
  display.setCursor(80, 100);
  display.print("PRINTING");
  
  display.setFont(&FreeSans9pt7b);
  
  // Current Temperature
  display.setCursor(50, 160);
  display.print("Current Temperature:");
  display.setFont(&FreeSansBold12pt7b);
  display.setCursor(50, 195);
  if (currentDisplayTemp > -999.0) {
    display.print(currentDisplayTemp, 1);
    display.print(" C");
  } else {
    display.print("--- C");
  }
  
  // Selected Temperature
  display.setFont(&FreeSans9pt7b);
  display.setCursor(50, 235);
  display.print("Selected Temperature:");
  display.setFont(&FreeSansBold12pt7b);
  display.setCursor(50, 270);
  display.print(Setpoint, 1);
  display.print(" C");
  
  // Remaining volumes
  display.setFont(&FreeSans9pt7b);
  display.setCursor(50, 320);
  display.print("Remaining:");
  display.setCursor(50, 350);
  display.print("M1: ");
  display.print(config.remaining1, 2);
  display.print(" mL");
  display.setCursor(50, 380);
  display.print("M2: ");
  display.print(config.remaining2, 2);
  display.print(" mL");
  
  // Dispensed volumes
  display.setCursor(50, 430);
  display.print("Dispensed:");
  display.setCursor(50, 460);
  display.print("M1: ");
  display.print(config.dispensed1, 2);
  display.print(" mL");
  display.setCursor(50, 490);
  display.print("M2: ");
  display.print(config.dispensed2, 2);
  display.print(" mL");
  
  // Progress indicator
  float progress1 = (config.dispensed1 / config.syringe_vol1) * 100.0;
  display.setCursor(50, 530);
  display.print("Progress: ");
  display.print(progress1, 0);
  display.print(" %");
  
  // EMERGENCY STOP button
  display.fillRoundRect(140, 600, 200, 80, 10, CANCEL_COLOR);
  display.setFont(&FreeSansBold12pt7b);
  display.setTextColor(BUTTON_TEXT_COLOR);
  display.setCursor(165, 650);
  display.print("STOP");
}

void drawErrorPage(const char* message) {
  display.fillScreen(BG_COLOR);
  display.setFont(&FreeSansBold18pt7b);
  display.setTextColor(CANCEL_COLOR);
  display.setCursor(100, 200);
  display.print("ERROR");
  
  display.setFont(&FreeSans9pt7b);
  display.setTextColor(TEXT_COLOR);
  display.setCursor(80, 300);
  display.print(message);
  
  display.fillRoundRect(165, 450, 150, 70, 10, BUTTON_COLOR);
  display.setTextColor(BUTTON_TEXT_COLOR);
  display.setCursor(205, 495);
  display.print("HOME");
}

// ==================== TOUCH HANDLERS ====================
void handleWelcomeTouch(int x, int y) {
  // HOME MOTORS button
  if (x >= 90 && x <= 390 && y >= 600 && y <= 670) {
    Serial.println("HOME MOTORS button pressed");
    currentPage = HOMING_PAGE;
    drawHomingPage();
    delay(500);
    
    if (homeMotors()) {
      Serial.println("Homing successful!");
      drawWelcomePage();
      currentPage = WELCOME;
    } else {
      Serial.println("Homing failed!");
      drawErrorPage("Homing failed!");
      currentPage = ERROR_PAGE;
    }
    return;
  }
  
  // START button
  if (x >= 140 && x <= 340 && y >= 700 && y <= 770) {
    currentPage = HOME;
    drawHomePage();
  }
}

void handleHomeTouch(int x, int y) {
  if (x >= 40 && x <= 440) {
    if (y >= 120 && y <= 210) {
      currentPage = TEMPERATURE_PAGE;
      tempSelection = selectedTemp;
      drawParameterPage(tempOptions, numTempOptions, tempSelection, "Temperature", "C");
    } else if (y >= 230 && y <= 320) {
      currentPage = VOLUME1;
      tempSelection = selectedVol1;
      drawParameterPage(volOptions, numVolOptions, tempSelection, "Volume 1", "mL");
    } else if (y >= 340 && y <= 430) {
      currentPage = VOLUME2;
      tempSelection = selectedVol2;
      drawParameterPage(volOptions, numVolOptions, tempSelection, "Volume 2", "mL");
    } else if (y >= 450 && y <= 540) {
      currentPage = CONCENTRATION;
      tempSelection = selectedConc;
      drawParameterPage(concOptions, numConcOptions, tempSelection, "Concentration", "%");
    } else if (y >= 560 && y <= 650) {
      currentPage = SPEED;
      tempSelection = selectedSpeed;
      drawParameterPage(speedOptions, numSpeedOptions, tempSelection, "Speed", "mm/s");
    }
  }
  
  // Check PRINT button
  if (x >= 140 && x <= 340 && y >= 690 && y <= 770) {
    // Check if all parameters are selected
    if (selectedTemp < 0 || selectedVol1 < 0 || selectedVol2 < 0 || 
        selectedConc < 0 || selectedSpeed < 0) {
      Serial.println("Error: Not all parameters selected");
      currentPage = ERROR_PAGE;
      drawErrorPage("Please specify all parameters");
    } else {
      Serial.println("All parameters selected, proceeding to confirm");
      currentPage = PRINT_CONFIRM;
      drawPrintConfirmPage();
    }
  }
}

void handleParameterTouch(int x, int y, int* options, int numOptions, float* targetVar) {
  // +/- button handling
  int boxX = 40;
  int boxY = 75;
  int boxWidth = 260;
  int boxHeight = 100;
  int buttonSize = 70;
  int buttonSpacing = 10;
  
  // Check - button (decrease)
  if (x >= boxX && x <= boxX + buttonSize && y >= boxY && y <= boxY + boxHeight) {
    if (tempSelection >= 0) {
      // Find current index and go to previous
      for (int i = 0; i < numOptions; i++) {
        if (abs(options[i] - tempSelection) < 0.01) {
          if (i > 0) {
            tempSelection = options[i - 1];
            const char* title;
            const char* unit;
            getCurrentPageInfo(&title, &unit);
            drawParameterPage(options, numOptions, tempSelection, title, unit);
          }
          return;
        }
      }
    }
    return;
  }
  
  // Check + button (increase)
  int plusX = boxX + buttonSize + buttonSpacing + boxWidth + buttonSpacing;
  if (x >= plusX && x <= plusX + buttonSize && y >= boxY && y <= boxY + boxHeight) {
    if (tempSelection >= 0) {
      // Find current index and go to next
      for (int i = 0; i < numOptions; i++) {
        if (abs(options[i] - tempSelection) < 0.01) {
          if (i < numOptions - 1) {
            tempSelection = options[i + 1];
            const char* title;
            const char* unit;
            getCurrentPageInfo(&title, &unit);
            drawParameterPage(options, numOptions, tempSelection, title, unit);
          }
          return;
        }
      }
    } else {
      // If not set, start with first option
      tempSelection = options[0];
      const char* title;
      const char* unit;
      getCurrentPageInfo(&title, &unit);
      drawParameterPage(options, numOptions, tempSelection, title, unit);
    }
    return;
  }
  
  // Check CLEAR button
  if (x >= 170 && x <= 310 && y >= 630 && y <= 680) {
    tempSelection = -1;
    const char* title;
    const char* unit;
    getCurrentPageInfo(&title, &unit);
    drawParameterPage(options, numOptions, tempSelection, title, unit);
    return;
  }
  
  // Check CONFIRM button
  if (x >= 140 && x <= 340 && y >= 700 && y <= 770) {
    if (currentPage == TEMPERATURE_PAGE && tempSelection > 0) {
      selectedTemp = tempSelection;
      Setpoint = selectedTemp;
      Serial.print("Temperature setpoint updated: ");
      Serial.print(Setpoint);
      Serial.println(" C");
    } else if (tempSelection >= 0) {
      *targetVar = tempSelection;
    }
    currentPage = HOME;
    drawHomePage();
    return;
  }
  
  // Option button grid - 3 columns
  int cols = 3;
  int buttonWidth = 120;
  int buttonHeight = 80;
  int spacingX = 20;
  int spacingY = 20;
  int startX = 40;
  int startY = 200;
  
  for (int i = 0; i < numOptions; i++) {
    int col = i % cols;
    int row = i / cols;
    int bx = startX + col * (buttonWidth + spacingX);
    int by = startY + row * (buttonHeight + spacingY);
    
    if (x >= bx && x <= bx + buttonWidth && y >= by && y <= by + buttonHeight) {
      tempSelection = options[i];
      const char* title;
      const char* unit;
      getCurrentPageInfo(&title, &unit);
      drawParameterPage(options, numOptions, tempSelection, title, unit);
      break;
    }
  }
}

void handlePrintConfirmTouch(int x, int y) {
  if (x >= 60 && x <= 220 && y >= 650 && y <= 730) {
    Serial.println("Confirm - starting print sequence");
    
    // Enable heat control with selected temperature
    Setpoint = selectedTemp;
    heatControlEnabled = true;
    systemReady = false;
    Serial.print("Heat control enabled - Target: ");
    Serial.print(Setpoint);
    Serial.println(" C");
    
    currentPage = LOADING_PAGE;
    drawLoadingPage();
    delay(500);
    
    // Step 1: Load motors
    if (!executeLoad()) {
      drawErrorPage("Load failed");
      currentPage = ERROR_PAGE;
      return;
    }
    drawLoadingPage();
    delay(500);
    
    // Step 2: Setup with selected parameters
    if (!executeSetup(selectedVol1, selectedVol2, selectedConc)) {
      drawErrorPage("Setup failed");
      currentPage = ERROR_PAGE;
      return;
    }
    drawLoadingPage();
    delay(500);
    
    // Step 3: Prime motors
    if (!executePrime()) {
      drawErrorPage("Prime failed");
      currentPage = ERROR_PAGE;
      return;
    }
    drawLoadingPage();
    delay(500);
    
    // Go to temperature ready page - wait for stabilization
    currentPage = TEMP_READY;
    tempStableTime = 0;
    systemReady = false;  // Reset ready flag
    drawTempReadyPage();
    Serial.println("Waiting for temperature stabilization and motor homing...");
  }
  
  if (x >= 260 && x <= 420 && y >= 650 && y <= 730) {
    Serial.println("Cancel button pressed");
    currentPage = HOME;
    drawHomePage();
  }
}

void handleTempReadyTouch(int x, int y) {
  // Check YES button (only active when systemReady)
  if (x >= 90 && x <= 390 && y >= 600 && y <= 680 && systemReady) {
    Serial.println("YES button pressed - proceeding to print");
    currentPage = READY_TO_PRINT;
    drawReadyToPrintPage();
  }
  
  // Check HOME button
  if (x >= 140 && x <= 340 && y >= 700 && y <= 760) {
    // Turn off heat when going home
    heatControlEnabled = false;
    analogWrite(MOSFET_PIN, 0);
    Serial.println("Heat control disabled");
    currentPage = HOME;
    drawHomePage();
  }
}

void handleReadyToPrintTouch(int x, int y) {
  // Check PRINT button
  if (x >= 90 && x <= 390 && y >= 500 && y <= 620) {
    Serial.println("PRINT button pressed - starting continuous extrusion");
    isPrinting = true;
    currentPage = PRINTING_PAGE;
    drawPrintingPage();
  }
  
  // Check HOME button
  if (x >= 140 && x <= 340 && y >= 670 && y <= 740) {
    // Turn off heat when going home
    heatControlEnabled = false;
    analogWrite(MOSFET_PIN, 0);
    Serial.println("Heat control disabled");
    currentPage = HOME;
    drawHomePage();
  }
}

void handlePrintingTouch(int x, int y) {
  // Check STOP button
  if (x >= 140 && x <= 340 && y >= 600 && y <= 680) {
    Serial.println("EMERGENCY STOP button pressed");
    isPrinting = false;
    
    // Immediately halt motors
    tic1.haltAndHold();
    tic2.haltAndHold();
    delay(100);
    
    // Read actual positions where motors stopped
    long stopped_pos1 = tic1.getCurrentPosition();
    long stopped_pos2 = tic2.getCurrentPosition();
    
    // Update Arduino tracker
    arduino_pos1 = stopped_pos1;
    arduino_pos2 = stopped_pos2;
    
    // Update remaining volumes based on where we actually stopped
    float actualDispensed1 = stepsToMl(config.prime_pos1 - arduino_pos1);
    float actualDispensed2 = stepsToMl(config.prime_pos2 - arduino_pos2);
    config.remaining1 = config.syringe_vol1 - actualDispensed1;
    config.remaining2 = config.syringe_vol2 - actualDispensed2;
    config.dispensed1 = actualDispensed1;
    config.dispensed2 = actualDispensed2;
    
    Serial.print("Stopped at positions - M1: ");
    Serial.print(arduino_pos1);
    Serial.print(", M2: ");
    Serial.println(arduino_pos2);
    Serial.print("Remaining - M1: ");
    Serial.print(config.remaining1);
    Serial.print(" mL, M2: ");
    Serial.print(config.remaining2);
    Serial.println(" mL");
    
    current_state = COMPLETE;
    currentPage = READY_TO_PRINT;
    drawReadyToPrintPage();
  }
}

void handleLoadingTouch(int x, int y) {
  if (x >= 140 && x <= 340 && y >= 680 && y <= 760) {
    // Turn off heat when going home
    heatControlEnabled = false;
    analogWrite(MOSFET_PIN, 0);
    Serial.println("Heat control disabled");
    currentPage = HOME;
    drawHomePage();
  }
}

void handleErrorTouch(int x, int y) {
  if (x >= 165 && x <= 315 && y >= 450 && y <= 520) {
    // Turn off heat when going home
    heatControlEnabled = false;
    analogWrite(MOSFET_PIN, 0);
    Serial.println("Heat control disabled");
    currentPage = HOME;
    drawHomePage();
  }
}

void handleTouch(int x, int y) {
  switch (currentPage) {
    case WELCOME:
      handleWelcomeTouch(x, y);
      break;
    case HOME:
      handleHomeTouch(x, y);
      break;
    case TEMPERATURE_PAGE:
      handleParameterTouch(x, y, tempOptions, numTempOptions, &selectedTemp);
      break;
    case VOLUME1:
      handleParameterTouch(x, y, volOptions, numVolOptions, &selectedVol1);
      break;
    case VOLUME2:
      handleParameterTouch(x, y, volOptions, numVolOptions, &selectedVol2);
      break;
    case CONCENTRATION:
      handleParameterTouch(x, y, concOptions, numConcOptions, &selectedConc);
      break;
    case SPEED:
      handleParameterTouch(x, y, speedOptions, numSpeedOptions, &selectedSpeed);
      break;
    case PRINT_CONFIRM:
      handlePrintConfirmTouch(x, y);
      break;
    case LOADING_PAGE:
      handleLoadingTouch(x, y);
      break;
    case TEMP_READY:
      handleTempReadyTouch(x, y);
      break;
    case READY_TO_PRINT:
      handleReadyToPrintTouch(x, y);
      break;
    case PRINTING_PAGE:
      handlePrintingTouch(x, y);
      break;
    case ERROR_PAGE:
      handleErrorTouch(x, y);
      break;
  }
}

void getCurrentPageInfo(const char** title, const char** unit) {
  if (currentPage == TEMPERATURE_PAGE) {
    *title = "Temperature";
    *unit = "C";
  } else if (currentPage == VOLUME1) {
    *title = "Volume 1";
    *unit = "mL";
  } else if (currentPage == VOLUME2) {
    *title = "Volume 2";
    *unit = "mL";
  } else if (currentPage == CONCENTRATION) {
    *title = "Concentration";
    *unit = "%";
  } else if (currentPage == SPEED) {
    *title = "Speed";
    *unit = "mm/s";
  }
}

// ==================== CONTINUOUS PRINTING ====================
void performContinuousPrint() {
  // Calculate how much can be extruded based on remaining volumes
  float maxVol1 = config.remaining1;
  float maxVol2 = config.remaining2 / (config.ratio2 / config.ratio1);
  float volumeToExtrude = min(maxVol1, maxVol2);
  
  // Extrude in small increments for better control
  float increment = 0.5; // 0.5mL at a time
  if (volumeToExtrude > increment) {
    volumeToExtrude = increment;
  }
  
  if (volumeToExtrude > 0.01) {
    if (executeExtrude(volumeToExtrude, selectedSpeed)) {
      drawPrintingPage();
    } else {
      // Extrusion failed or completed
      isPrinting = false;
      if (config.remaining1 < 0.1 || config.remaining2 < 0.1) {
        Serial.println("Print complete - volumes depleted");
        drawErrorPage("Print Complete!");
        currentPage = ERROR_PAGE;
      } else {
        Serial.println("Extrusion error");
        drawErrorPage("Extrusion error");
        currentPage = ERROR_PAGE;
      }
    }
  } else {
    // Not enough material left
    isPrinting = false;
    Serial.println("Print complete - volumes depleted");
    drawErrorPage("Print Complete!");
    currentPage = ERROR_PAGE;
  }
}

// ==================== SETUP ====================
void setup() {
  Serial.begin(115200);
  while (!Serial && millis() < 3000);
  
  delay(1000);
  
  Serial.println("\n================================");
  Serial.println("  BIOPRINT AM - UNIFIED v3.0");
  Serial.println("  + PID TEMPERATURE CONTROL");
  Serial.println("================================");
  
  // Set ADC resolution for GIGA
  analogReadResolution(12);
  
  // Initialize heat control pin
  pinMode(MOSFET_PIN, OUTPUT);
  analogWrite(MOSFET_PIN, 0);
  
  display.begin();
  touchDetector.begin();
  display.setRotation(0);
  display.fillScreen(BG_COLOR);
  
  initializeMotors();
  updateTemperatures();
  
  Serial.println("System ready!");
  Serial.print("Initial temperatures - A0: ");
  Serial.print(currentTemperatures[0], 2);
  Serial.print(" C, A1: ");
  Serial.print(currentTemperatures[1], 2);
  Serial.println(" C");
  Serial.print("PID Kp = ");
  Serial.println(Kp, 0);
  
  drawWelcomePage();
}

// ==================== MAIN LOOP ====================
void loop() {
  // Update temperatures periodically
  if (millis() - lastTempUpdate > TEMP_UPDATE_INTERVAL) {
    updateTemperatures();
    lastTempUpdate = millis();
    
    if (currentPage == LOADING_PAGE) {
      drawLoadingPage();
    }
    
    // Check for temperature stabilization on TEMP_READY page
    if (currentPage == TEMP_READY) {
      bool tempStable = (currentDisplayTemp > -999.0) && 
                        (abs(currentDisplayTemp - Setpoint) <= TEMP_TOLERANCE);
      bool actuatorsReady = (current_state == PRIMED) && motorsHomed;
      
      if (tempStable && actuatorsReady) {
        if (tempStableTime == 0) {
          tempStableTime = millis();
        } else if (millis() - tempStableTime >= TEMP_STABLE_DURATION) {
          if (!systemReady) {
            systemReady = true;
            Serial.println("System ready! Temperature stable and actuators initialized.");
            drawTempReadyPage();
          }
        }
      } else {
        tempStableTime = 0;
        if (systemReady) {
          systemReady = false;
          drawTempReadyPage();
        }
      }
      
      // Periodic update of TEMP_READY page
      static unsigned long lastTempReadyUpdate = 0;
      if (millis() - lastTempReadyUpdate > 2000) {
        drawTempReadyPage();
        lastTempReadyUpdate = millis();
      }
    }
  }
  
  // Apply PID heat control (runs continuously when enabled)
  applyHeatControl();
  
  // Handle continuous printing
  if (isPrinting && currentPage == PRINTING_PAGE) {
    performContinuousPrint();
  }
  
  // Handle touch input
  uint8_t contacts;
  GDTpoint_t points[5];
  contacts = touchDetector.getTouchPoints(points);
  
  if (contacts > 0 && !lastTouchState) {
    int x = points[0].x;
    int y = points[0].y;
    
    Serial.print("Touch at X: ");
    Serial.print(x);
    Serial.print(" Y: ");
    Serial.println(y);
    
    handleTouch(x, y);
    lastTouchState = true;
    delay(250);
  } else if (contacts == 0) {
    lastTouchState = false;
  }
  
  // Keep motors responsive
  if (current_state == EXTRUDING) {
    tic1.resetCommandTimeout();
    tic2.resetCommandTimeout();
  }
  
  delay(10);
}
