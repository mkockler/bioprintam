/*
 * BioPrint AM - Unified Control System with PID Temperature Control
 * Arduino GIGA R1 WiFi
 * 
 * Features:
 * - Full UI with adjustable parameters
 * - PID P-only control (Kp=150) for heat mat temperature
 * - Temperature maintenance using thermistors A0, A1
 * - Automated extrusion control
 * - Emergency stop functionality
 * - Motor homing/reset capability
 * - UPDATED: Improved motor control from finalmotorcontrol.ino
 * 
 * Hardware:
 * - Arduino GIGA R1 WiFi
 * - 2× 10K NTC thermistors (β=3435) on A0, A1 (heat mats)
 * - 2× 10K NTC thermistors (β=3950) on A2, A3 (system monitoring)
 * - MOSFET on Pin 9 (PWM heat control)
 * - 2× Tic stepper controllers (I2C addresses 14, 15)
 */

#include <Tic.h>
#include <Wire.h>
#include <math.h>
#include "Arduino_GigaDisplay_GFX.h"
#include "Arduino_GigaDisplayTouch.h"
#include <Fonts/FreeSansBold12pt7b.h>
#include <Fonts/FreeSans9pt7b.h>
#include <Fonts/FreeSansBold18pt7b.h>

// ==================== DISPLAY & TOUCH ====================
GigaDisplay_GFX display;
Arduino_GigaDisplayTouch touchDetector;

// Colors
#define BG_COLOR 0xFFFF
#define BUTTON_COLOR 0x0010
#define BUTTON_SELECTED_COLOR 0x4208
#define TEXT_COLOR 0x0010
#define BUTTON_TEXT_COLOR 0xFFFF
#define CONFIRM_COLOR 0xA9CF
#define CANCEL_COLOR 0xF800
#define CLEAR_COLOR 0xFD20

// ==================== MOTOR CONFIGURATION ====================
#define MOTOR1_ADDRESS 14
#define MOTOR2_ADDRESS 15

const float STEPS_PER_ML = 975.0f;  // (11750 - 2000) / 10mL = 975 steps/mL
const float MM_PER_STEP = 0.00605f;
const float MM_PER_ML = 6.05f;
const float MAX_VOLUME_ML = 10.0f;   // Maximum syringe volume
const long SYRINGE_ZERO = 2000L;     // Syringe at 0mL (empty position)
const long SYRINGE_MAX = 11750L;     // Syringe at 10mL (full position)
const long LOAD_POSITION = 12000L;   // Loading position (above max for easy loading)
const float MAX_SPEED_MMS = 3.0f;
const long MAX_SPEED_STEPS_S = 496L;
const int MAX_ACCEL = 1000;
const int POSITION_TOLERANCE = 10;

TicI2C tic1;
TicI2C tic2;

// ==================== HEAT CONTROL CONFIGURATION ====================
const int MOSFET_PIN = 9;  // PWM pin for heat control

// ==================== THERMISTOR CONFIGURATION ====================
// A0, A1: Heat mat thermistors (β=3435) - used for PID control
// A2, A3: System thermistors (β=3950) - monitoring only
const int numThermistors = 4;
const int thermistorPins[numThermistors] = {A0, A1, A2, A3};

// Thermistor constants for A0, A1 (heat mats)
const float seriesResistor_heat = 10000.0;
const float thermistorNominal_heat = 10000.0;
const float temperatureNominal_heat = 25.0;
const float betaCoefficient_heat = 3435.0;

// Thermistor constants for A2, A3 (system)
const float seriesResistor_sys = 10000.0;
const float thermistorNominal_sys = 10000.0;
const float temperatureNominal_sys = 25.0;
const float betaCoefficient_sys = 3950.0;

float currentTemperatures[numThermistors] = {-999, -999, -999, -999};
unsigned long lastTempUpdate = 0;
const unsigned long TEMP_UPDATE_INTERVAL = 1000;

// ==================== PID CONTROL PARAMETERS ====================
// PID 1: Heat Mat Control (A0, A1) - Always aims for 80°C
float Setpoint_HeatMat = 80.0;      // Heat mats always target 80°C
float Kp_HeatMat = 150.0;           // Proportional gain for heat mats
float Input_HeatMat = 25.0;         // Average of A0 and A1
float Output_HeatMat = 0.0;         // PWM output for heat mats (0-255)

// PID 2: Syringe Control (A2, A3) - User-selected temperature
float Setpoint_Syringe = 35.0;      // Target temperature for syringes (user-selected)
float Kp_Syringe = 150.0;           // Proportional gain for syringes
float Input_Syringe = 25.0;         // Average of A2 and A3
float Output_Syringe = 0.0;         // PWM output for syringes (0-255)

// Control mode
bool heatControlEnabled = false;
bool syringesTempReached = false;   // Track if syringes reached target temp

// ==================== STATE MACHINE ====================
enum SystemState {
  UNINITIALIZED,
  LOAD,
  SETUP,
  PRIMED,
  READY,
  EXTRUDING,
  COMPLETE,
  SAFE_MODE
};

SystemState current_state = UNINITIALIZED;
const char* state_names[] = {"UNINITIALIZED", "LOAD", "SETUP", "PRIMED", "READY", "EXTRUDING", "COMPLETE", "SAFE_MODE"};

// ==================== UI PAGE DEFINITIONS ====================
enum Page {
  WELCOME,
  HOME,
  TEMPERATURE_PAGE,
  VOLUME1,
  VOLUME2,
  CONCENTRATION,
  SPEED,
  PRINT_CONFIRM,
  LOADING_PAGE,
  HOMING_PAGE,
  LOADING_SYRINGES,  // Page for initiating homing
  WAITING_FOR_SYRINGES,  // Page after motors at 12000, waiting for user to load
  TEMP_READY,
  READY_TO_PRINT,
  PRINTING_PAGE,
  PRINT_DONE,
  ERROR_PAGE
};

Page currentPage = WELCOME;

// Temperature stabilization tracking
float currentDisplayTemp = 25.0;  // Average of A2 and A3 for display
bool systemReady = false;
unsigned long tempStableTime = 0;
const unsigned long TEMP_STABLE_DURATION = 3000;  // 3 seconds stable
const float TEMP_TOLERANCE = 2.0;  // Within 2°C of target

// ==================== POSITION TRACKING ====================
long arduino_pos1 = 0;  // Motor 1 position (source of truth)
long arduino_pos2 = 0;  // Motor 2 position (source of truth)
bool motorsHomed = false;  // Track if motors have been homed

// UI parameter storage (declared early for use in homeMotors)
float selectedTemp = -1;
float selectedVol1 = -1;
float selectedVol2 = -1;
float selectedConc = -1;
float selectedSpeed = -1;
float tempSelection = -1;

// Homing function - moves motors to LOAD_POSITION for syringe loading
bool homeMotors() {
  Serial.println("\n=== MOVING TO LOAD POSITION ===");
  
  // Read actual TIC positions
  long actual_pos1 = tic1.getCurrentPosition();
  long actual_pos2 = tic2.getCurrentPosition();
  
  Serial.print("Current TIC positions: M1=");
  Serial.print(actual_pos1);
  Serial.print(", M2=");
  Serial.println(actual_pos2);
  
  // Update arduino tracker to match actual positions
  arduino_pos1 = actual_pos1;
  arduino_pos2 = actual_pos2;
  
  // Move to loading position (12000 - above maximum for easy syringe loading)
  Serial.println("Moving to loading position (12000)...");
  if (!moveMotorsTo(LOAD_POSITION, LOAD_POSITION, MAX_SPEED_MMS)) {
    Serial.println("Failed to reach loading position!");
    return false;
  }
  
  Serial.println("At loading position - ready for syringe loading");
  return true;
}

// Complete homing by moving to selected volumes
bool completeHoming() {
  Serial.println("\n=== COMPLETING HOMING ===");
  
  // Move to the position based on selected volumes
  long target_pos1, target_pos2;
  
  if (selectedVol1 > 0 && selectedVol2 > 0) {
    // Move to user-selected volume positions
    target_pos1 = mlToSteps(selectedVol1);
    target_pos2 = mlToSteps(selectedVol2);
    Serial.print("Moving to selected volumes: M1=");
    Serial.print(selectedVol1);
    Serial.print("mL (");
    Serial.print(target_pos1);
    Serial.print(" steps), M2=");
    Serial.print(selectedVol2);
    Serial.print("mL (");
    Serial.print(target_pos2);
    Serial.println(" steps)");
  } else {
    // No volumes selected yet, move to maximum (10mL = 11750 steps)
    target_pos1 = SYRINGE_MAX;
    target_pos2 = SYRINGE_MAX;
    Serial.println("Moving to maximum position (10mL = 11750 steps)...");
  }
  
  if (!moveMotorsTo(target_pos1, target_pos2, MAX_SPEED_MMS)) {
    Serial.println("Failed to reach target position!");
    return false;
  }
  
  // Set current positions as reference
  arduino_pos1 = target_pos1;
  arduino_pos2 = target_pos2;
  
  tic1.haltAndSetPosition(target_pos1);
  tic2.haltAndSetPosition(target_pos2);
  
  motorsHomed = true;
  Serial.println("Homing complete!");
  Serial.print("Motors at: M1=");
  Serial.print(arduino_pos1);
  Serial.print(" (");
  Serial.print(stepsToMl(arduino_pos1), 2);
  Serial.print("mL), M2=");
  Serial.print(arduino_pos2);
  Serial.print(" (");
  Serial.print(stepsToMl(arduino_pos2), 2);
  Serial.println("mL)");
  
  return true;
}

// ==================== SYSTEM CONFIGURATION ====================
struct SystemConfig {
  float ratio1 = 1.0f;
  float ratio2 = 1.0f;
  float syringe_vol1 = 10.0f;
  float syringe_vol2 = 10.0f;
  float extrude_vol1 = 1.0f;
  float extrude_speed = 2.0f;
  float dispensed1 = 0.0f;
  float dispensed2 = 0.0f;
  float remaining1 = 10.0f;
  float remaining2 = 10.0f;
  long prime_pos1 = SYRINGE_MAX;  // Start at maximum syringe position
  long prime_pos2 = SYRINGE_MAX;  // Start at maximum syringe position
} config;

// UI options
int tempOptions[] = {30, 32, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80};
int numTempOptions = 12;
int concOptions[] = {0, 25, 50, 75, 100};
int numConcOptions = 5;
int volOptions[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int numVolOptions = 10;
int speedOptions[] = {1, 2, 3, 4, 5};
int numSpeedOptions = 5;

bool lastTouchState = false;
bool isPrinting = false;

// ==================== UTILITY FUNCTIONS ====================
inline long mlToSteps(float ml) {
  // Convert mL to steps relative to SYRINGE_ZERO
  return SYRINGE_ZERO + (long)(ml * STEPS_PER_ML);
}

inline float stepsToMl(long steps) {
  // Convert absolute steps to mL (relative to SYRINGE_ZERO)
  return (float)(steps - SYRINGE_ZERO) / STEPS_PER_ML;
}

inline long mmsToStepsPerSec(float mm_per_s) {
  long steps_s = (long)(mm_per_s / MM_PER_STEP);
  return constrain(steps_s, 1, MAX_SPEED_STEPS_S);
}

inline long stepsPerSecToTicUnits(long steps_per_sec) {
  return steps_per_sec * 10000L;
}

// ==================== THERMISTOR FUNCTIONS ====================
float readThermistor(int pin, bool isHeatMat) {
  int adcValue = analogRead(pin);
  
  if (adcValue <= 10 || adcValue >= 4095) {
    return -999.0;
  }
  
  // Select appropriate constants based on thermistor type
  float seriesR = isHeatMat ? seriesResistor_heat : seriesResistor_sys;
  float nominalR = isHeatMat ? thermistorNominal_heat : thermistorNominal_sys;
  float nominalT = isHeatMat ? temperatureNominal_heat : temperatureNominal_sys;
  float beta = isHeatMat ? betaCoefficient_heat : betaCoefficient_sys;
  
  // Convert ADC to resistance
  float voltageRatio = (4095.0 / adcValue) - 1.0;
  float resistance = seriesR / voltageRatio;
  
  // Steinhart-Hart equation
  float steinhart = resistance / nominalR;
  steinhart = log(steinhart);
  steinhart /= beta;
  steinhart += 1.0 / (nominalT + 273.15);
  steinhart = 1.0 / steinhart;
  steinhart -= 273.15;
  
  return steinhart;
}

void updateTemperatures() {
  // A0, A1: Heat mat sensors (β=3435)
  currentTemperatures[0] = readThermistor(thermistorPins[0], true);
  currentTemperatures[1] = readThermistor(thermistorPins[1], true);
  
  // A2, A3: System sensors (β=3950)
  currentTemperatures[2] = readThermistor(thermistorPins[2], false);
  currentTemperatures[3] = readThermistor(thermistorPins[3], false);
  
  // Calculate heat mat temperature (average of A0 and A1) - for PID 1
  if (currentTemperatures[0] > -999.0 && currentTemperatures[1] > -999.0) {
    Input_HeatMat = (currentTemperatures[0] + currentTemperatures[1]) / 2.0;
  } else if (currentTemperatures[0] > -999.0) {
    Input_HeatMat = currentTemperatures[0];
  } else if (currentTemperatures[1] > -999.0) {
    Input_HeatMat = currentTemperatures[1];
  } else {
    Input_HeatMat = -999.0;
  }
  
  // Calculate syringe temperature (average of A2 and A3) - for PID 2 and display
  if (currentTemperatures[2] > -999.0 && currentTemperatures[3] > -999.0) {
    Input_Syringe = (currentTemperatures[2] + currentTemperatures[3]) / 2.0;
    currentDisplayTemp = Input_Syringe;  // Display syringe temp as "current"
  } else if (currentTemperatures[2] > -999.0) {
    Input_Syringe = currentTemperatures[2];
    currentDisplayTemp = currentTemperatures[2];
  } else if (currentTemperatures[3] > -999.0) {
    Input_Syringe = currentTemperatures[3];
    currentDisplayTemp = currentTemperatures[3];
  } else {
    Input_Syringe = -999.0;
    currentDisplayTemp = -999.0;
  }
  
  // Check if syringes have reached target temperature
  if (Input_Syringe > -999.0 && abs(Input_Syringe - Setpoint_Syringe) <= TEMP_TOLERANCE) {
    syringesTempReached = true;
  } else {
    syringesTempReached = false;
  }
}

// ==================== DUAL PID CONTROL ====================
void computeDualPID() {
  if (!heatControlEnabled || Input_HeatMat < 0 || Input_Syringe < 0) {
    Output_HeatMat = 0;
    Output_Syringe = 0;
    return;
  }
  
  // PID 1: Heat Mat Control (A0, A1) - Always aims for 80°C
  float error_HeatMat = Setpoint_HeatMat - Input_HeatMat;
  Output_HeatMat = Kp_HeatMat * error_HeatMat;
  Output_HeatMat = constrain(Output_HeatMat, 0, 255);
  
  // PID 2: Syringe Control (A2, A3) - User-selected temperature
  float error_Syringe = Setpoint_Syringe - Input_Syringe;
  Output_Syringe = Kp_Syringe * error_Syringe;
  Output_Syringe = constrain(Output_Syringe, 0, 255);
}

void applyHeatControl() {
  computeDualPID();
  
  if (!heatControlEnabled) {
    analogWrite(MOSFET_PIN, 0);
    return;
  }
  
  // Determine which PID controls the heat mats
  int finalPWM = 0;
  
  if (!syringesTempReached) {
    // Phase 1: Syringes haven't reached target yet
    // Use heat mat PID (target 80°C) - full heating
    finalPWM = (int)Output_HeatMat;
    Serial.print("Phase 1 - Heat Mat PID: ");
    Serial.print(finalPWM);
    Serial.println(" PWM");
  } else {
    // Phase 2: Syringes reached target
    // Use SMALLER of the two PID values to modulate
    finalPWM = min((int)Output_HeatMat, (int)Output_Syringe);
    Serial.print("Phase 2 - Min(HeatMat:");
    Serial.print((int)Output_HeatMat);
    Serial.print(", Syringe:");
    Serial.print((int)Output_Syringe);
    Serial.print(") = ");
    Serial.println(finalPWM);
  }
  
  analogWrite(MOSFET_PIN, finalPWM);
}

// ==================== POSITION SYNCHRONIZATION ====================
bool syncPositionToTIC() {
  // Tell TIC boards where Arduino thinks they are
  tic1.haltAndSetPosition(arduino_pos1);
  tic2.haltAndSetPosition(arduino_pos2);
  
  delay(20);
  
  // Verify TIC accepted the positions
  long verify1 = tic1.getCurrentPosition();
  long verify2 = tic2.getCurrentPosition();
  
  if (abs(verify1 - arduino_pos1) > 5 || abs(verify2 - arduino_pos2) > 5) {
    Serial.println("ERROR: TIC position sync failed!");
    Serial.print("  Expected M1=");
    Serial.print(arduino_pos1);
    Serial.print(", Got=");
    Serial.println(verify1);
    Serial.print("  Expected M2=");
    Serial.print(arduino_pos2);
    Serial.print(", Got=");
    Serial.println(verify2);
    return false;
  }
  
  return true;
}

void updateArduinoTracker() {
  // Read actual positions from TIC (for monitoring only)
  // Arduino position is updated after successful movements
  long tic_pos1 = tic1.getCurrentPosition();
  long tic_pos2 = tic2.getCurrentPosition();
  
  // Only update if within tolerance (motors haven't drifted)
  if (abs(tic_pos1 - arduino_pos1) < 50 && abs(tic_pos2 - arduino_pos2) < 50) {
    arduino_pos1 = tic_pos1;
    arduino_pos2 = tic_pos2;
  }
}

// ==================== MOTOR CONTROL ====================
void initializeMotors() {
  Wire.begin();
  delay(100);
  
  Serial.println("Initializing motors via I2C...");
  
  // Initialize motor 1
  tic1.setAddress(MOTOR1_ADDRESS);
  delay(10);
  tic1.clearDriverError();
  tic1.energize();
  delay(10);
  tic1.exitSafeStart();
  delay(10);
  tic1.setMaxAccel(MAX_ACCEL * 100L);
  tic1.setMaxDecel(MAX_ACCEL * 100L);
  
  // Initialize motor 2
  tic2.setAddress(MOTOR2_ADDRESS);
  delay(10);
  tic2.clearDriverError();
  tic2.energize();
  delay(10);
  tic2.exitSafeStart();
  delay(10);
  tic2.setMaxAccel(MAX_ACCEL * 100L);
  tic2.setMaxDecel(MAX_ACCEL * 100L);
  
  Serial.println("Motors initialized");
  
  // Read initial TIC positions
  long init_pos1 = tic1.getCurrentPosition();
  long init_pos2 = tic2.getCurrentPosition();
  
  Serial.print("TIC startup positions: M1=");
  Serial.print(init_pos1);
  Serial.print(", M2=");
  Serial.println(init_pos2);
  
  // Set Arduino tracker to current TIC positions
  arduino_pos1 = init_pos1;
  arduino_pos2 = init_pos2;
  
  Serial.println("*** Please use HOME MOTORS button to calibrate ***");
}

bool moveMotorsTo(long target1, long target2, float speed_mms) {
  Serial.println("\n--- MOVEMENT ---");
  Serial.print("From: M1=");
  Serial.print(arduino_pos1);
  Serial.print(" (");
  Serial.print(stepsToMl(arduino_pos1), 2);
  Serial.print("mL), M2=");
  Serial.print(arduino_pos2);
  Serial.print(" (");
  Serial.print(stepsToMl(arduino_pos2), 2);
  Serial.println("mL)");
  
  Serial.print("To:   M1=");
  Serial.print(target1);
  Serial.print(" (");
  Serial.print(stepsToMl(target1), 2);
  Serial.print("mL), M2=");
  Serial.print(target2);
  Serial.print(" (");
  Serial.print(stepsToMl(target2), 2);
  Serial.println("mL)");
  
  // Sync Arduino position to TIC before moving
  if (!syncPositionToTIC()) {
    Serial.println("Cannot move - position sync failed");
    current_state = SAFE_MODE;
    return false;
  }
  
  // Clear any errors
  tic1.clearDriverError();
  tic2.clearDriverError();
  tic1.exitSafeStart();
  tic2.exitSafeStart();
  
  // Set speed
  long speed_steps = mmsToStepsPerSec(speed_mms);
  tic1.setMaxSpeed(stepsPerSecToTicUnits(speed_steps));
  tic2.setMaxSpeed(stepsPerSecToTicUnits(speed_steps));
  
  // Command movement
  tic1.setTargetPosition(target1);
  tic2.setTargetPosition(target2);
  
  Serial.print("Moving");
  
  // Monitor movement
  unsigned long last_update = millis();
  unsigned long start_time = millis();
  
  while (true) {
    // Reset command timeout
    tic1.resetCommandTimeout();
    tic2.resetCommandTimeout();
    
    // Read current positions
    long pos1 = tic1.getCurrentPosition();
    long pos2 = tic2.getCurrentPosition();
    
    // Check for errors
    uint16_t err1 = tic1.getErrorStatus();
    uint16_t err2 = tic2.getErrorStatus();
    
    if (err1 != 0 || err2 != 0) {
      Serial.println();
      Serial.println("Motor error during movement!");
      if (err1) {
        Serial.print("  M1 Error: 0x");
        Serial.println(err1, HEX);
      }
      if (err2) {
        Serial.print("  M2 Error: 0x");
        Serial.println(err2, HEX);
      }
      
      // Update Arduino tracker to where motors stopped
      arduino_pos1 = pos1;
      arduino_pos2 = pos2;
      
      Serial.print("Motors stopped at: M1=");
      Serial.print(arduino_pos1);
      Serial.print(", M2=");
      Serial.println(arduino_pos2);
      
      current_state = SAFE_MODE;
      return false;
    }
    
    // Check if arrived
    bool arrived1 = abs(pos1 - target1) <= POSITION_TOLERANCE;
    bool arrived2 = abs(pos2 - target2) <= POSITION_TOLERANCE;
    
    if (arrived1 && arrived2) {
      Serial.println();
      Serial.println("Movement complete");
      
      // Update Arduino tracker
      arduino_pos1 = target1;
      arduino_pos2 = target2;
      
      Serial.print("Final: M1=");
      Serial.print(arduino_pos1);
      Serial.print(", M2=");
      Serial.println(arduino_pos2);
      
      return true;
    }
    
    // Progress update every 2 seconds
    if (millis() - last_update > 2000) {
      Serial.print(".");
      last_update = millis();
    }
    
    // Timeout after 60 seconds
    if (millis() - start_time > 60000) {
      Serial.println();
      Serial.println("Movement timeout!");
      arduino_pos1 = pos1;
      arduino_pos2 = pos2;
      current_state = SAFE_MODE;
      return false;
    }
    
    delay(50);
  }
}

// ==================== STATE MACHINE FUNCTIONS ====================
bool executeLoad() {
  Serial.println("\n=== LOAD SEQUENCE ===");
  current_state = LOAD;
  
  if (!moveMotorsTo(LOAD_POSITION, LOAD_POSITION, MAX_SPEED_MMS)) {
    Serial.println("Load failed!");
    current_state = SAFE_MODE;
    return false;
  }
  
  Serial.println("Load complete - syringes at top");
  return true;
}

bool executeSetup(float vol1, float vol2, float concentration) {
  Serial.println("\n=== SETUP SEQUENCE ===");
  current_state = SETUP;
  
  config.syringe_vol1 = vol1;
  config.syringe_vol2 = vol2;
  
  float total_vol = vol1 + vol2;
  config.ratio1 = vol1 / total_vol;
  config.ratio2 = vol2 / total_vol;
  
  Serial.print("Volumes: M1=");
  Serial.print(config.syringe_vol1);
  Serial.print(" mL, M2=");
  Serial.print(config.syringe_vol2);
  Serial.println(" mL");
  Serial.print("Ratios: M1=");
  Serial.print(config.ratio1);
  Serial.print(", M2=");
  Serial.println(config.ratio2);
  
  config.remaining1 = config.syringe_vol1;
  config.remaining2 = config.syringe_vol2;
  config.dispensed1 = 0.0f;
  config.dispensed2 = 0.0f;
  
  return true;
}

bool executePrime() {
  Serial.println("\n=== PRIME SEQUENCE ===");
  current_state = PRIMED;
  
  config.prime_pos1 = arduino_pos1;
  config.prime_pos2 = arduino_pos2;
  
  Serial.print("Prime positions set: M1=");
  Serial.print(config.prime_pos1);
  Serial.print(", M2=");
  Serial.println(config.prime_pos2);
  
  return true;
}

bool executeExtrude(float volume_ml, float speed_mms) {
  Serial.println("\n=== EXTRUDE ===");
  Serial.print("Volume: ");
  Serial.print(volume_ml);
  Serial.print(" mL at ");
  Serial.print(speed_mms);
  Serial.println(" mm/s");
  
  current_state = EXTRUDING;
  
  float vol1_to_dispense = volume_ml * config.ratio1;
  float vol2_to_dispense = volume_ml * config.ratio2;
  
  if (vol1_to_dispense > config.remaining1 || vol2_to_dispense > config.remaining2) {
    Serial.println("ERROR: Not enough material remaining!");
    Serial.print("Need M1: ");
    Serial.print(vol1_to_dispense);
    Serial.print(" mL, Have: ");
    Serial.print(config.remaining1);
    Serial.println(" mL");
    Serial.print("Need M2: ");
    Serial.print(vol2_to_dispense);
    Serial.print(" mL, Have: ");
    Serial.print(config.remaining2);
    Serial.println(" mL");
    current_state = COMPLETE;
    return false;
  }
  
  // Calculate steps to move (converting mL to step delta)
  long steps1 = (long)(vol1_to_dispense * STEPS_PER_ML);
  long steps2 = (long)(vol2_to_dispense * STEPS_PER_ML);
  
  // Motors RETRACT to dispense (position decreases)
  long target1 = arduino_pos1 - steps1;
  long target2 = arduino_pos2 - steps2;
  
  // Safety check: don't go below SYRINGE_ZERO
  if (target1 < SYRINGE_ZERO || target2 < SYRINGE_ZERO) {
    Serial.println("ERROR: Target position would go below syringe zero!");
    Serial.print("Target M1: ");
    Serial.print(target1);
    Serial.print(", M2: ");
    Serial.print(target2);
    Serial.print(", Minimum allowed: ");
    Serial.println(SYRINGE_ZERO);
    current_state = COMPLETE;
    return false;
  }
  
  if (!moveMotorsTo(target1, target2, speed_mms)) {
    Serial.println("Extrusion movement failed!");
    current_state = SAFE_MODE;
    return false;
  }
  
  config.dispensed1 += vol1_to_dispense;
  config.dispensed2 += vol2_to_dispense;
  config.remaining1 -= vol1_to_dispense;
  config.remaining2 -= vol2_to_dispense;
  
  Serial.print("Dispensed: M1=");
  Serial.print(config.dispensed1);
  Serial.print(" mL, M2=");
  Serial.print(config.dispensed2);
  Serial.println(" mL");
  Serial.print("Remaining: M1=");
  Serial.print(config.remaining1);
  Serial.print(" mL, M2=");
  Serial.print(config.remaining2);
  Serial.println(" mL");
  
  return true;
}

// ==================== UI DRAWING FUNCTIONS ====================
void drawWelcomePage() {
  display.fillScreen(BG_COLOR);
  display.setFont(&FreeSansBold18pt7b);
  display.setTextColor(TEXT_COLOR);
  
  display.setCursor(80, 200);
  display.print("BioPrint AM");
  
  display.setFont(&FreeSans9pt7b);
  display.setCursor(120, 300);
  display.print("v3.0 + PID");
  
  display.setCursor(70, 400);
  display.print("Temperature Control");
  
  // Syringe position info
  display.setCursor(50, 450);
  display.print("Syringe Range:");
  display.setCursor(50, 475);
  display.print("0mL=2000  10mL=11750");
  
  // Temperature display
  display.setCursor(80, 520);
  display.print("Heat Mats:");
  display.setCursor(80, 545);
  display.print("A0: ");
  display.print(currentTemperatures[0], 1);
  display.print(" C  A1: ");
  display.print(currentTemperatures[1], 1);
  display.print(" C");
  
  // Homing status
  display.setCursor(80, 560);
  if (motorsHomed) {
    display.setTextColor(CONFIRM_COLOR);
    display.print("Motors: HOMED");
  } else {
    display.setTextColor(CANCEL_COLOR);
    display.print("Motors: NOT HOMED!");
  }
  
  // START button
  display.setTextColor(TEXT_COLOR);
  display.fillRoundRect(140, 630, 200, 100, 10, BUTTON_COLOR);
  display.setFont(&FreeSansBold18pt7b);
  display.setTextColor(BUTTON_TEXT_COLOR);
  display.setCursor(185, 690);
  display.print("START");
}

void drawHomingPage() {
  display.fillScreen(BG_COLOR);
  display.setFont(&FreeSansBold18pt7b);
  display.setTextColor(TEXT_COLOR);
  display.setCursor(100, 200);
  display.print("HOMING...");
  
  display.setFont(&FreeSans9pt7b);
  display.setCursor(50, 280);
  display.print("1. Moving to load position");
  display.setCursor(65, 310);
  display.print("(12000 steps)");
  
  display.setCursor(50, 360);
  display.print("2. Moving to volume position");
  if (selectedVol1 > 0 && selectedVol2 > 0) {
    display.setCursor(65, 390);
    display.print("M1: ");
    display.print(selectedVol1, 1);
    display.print("mL, M2: ");
    display.print(selectedVol2, 1);
    display.print("mL");
  } else {
    display.setCursor(65, 390);
    display.print("(10mL = 11750 steps)");
  }
  
  display.setCursor(80, 450);
  display.print("Please wait...");
  
  // Current positions
  display.setCursor(80, 520);
  display.print("M1: ");
  display.print(arduino_pos1);
  display.print(" steps (");
  display.print(stepsToMl(arduino_pos1), 1);
  display.print("mL)");
  display.setCursor(80, 550);
  display.print("M2: ");
  display.print(arduino_pos2);
  display.print(" steps (");
  display.print(stepsToMl(arduino_pos2), 1);
  display.print("mL)");
}

void drawLoadingSyringesPage() {
  display.fillScreen(BG_COLOR);
  display.setFont(&FreeSansBold18pt7b);
  display.setTextColor(TEXT_COLOR);
  display.setCursor(40, 150);
  display.print("LOAD SYRINGES");
  
  display.setFont(&FreeSans9pt7b);
  display.setCursor(50, 230);
  display.print("Instructions:");
  
  display.setCursor(50, 270);
  display.print("1. Press BEGIN HOMING");
  display.setCursor(50, 300);
  display.print("2. Wait for motors (12000)");
  display.setCursor(50, 330);
  display.print("3. Insert & fill syringes");
  display.setCursor(50, 360);
  display.print("4. Secure in holders");
  display.setCursor(50, 390);
  display.print("5. Motors move to volume");
  
  display.setCursor(50, 450);
  display.print("Target volumes:");
  if (selectedVol1 > 0 && selectedVol2 > 0) {
    display.setCursor(50, 480);
    display.print("M1: ");
    display.print(selectedVol1, 1);
    display.print("mL");
    display.setCursor(50, 510);
    display.print("M2: ");
    display.print(selectedVol2, 1);
    display.print("mL");
  } else {
    display.setCursor(50, 480);
    display.print("M1: 10.0 mL (max)");
    display.setCursor(50, 510);
    display.print("M2: 10.0 mL (max)");
  }
  
  // BEGIN HOMING button (center)
  display.fillRoundRect(90, 580, 300, 80, 10, CONFIRM_COLOR);
  display.setFont(&FreeSansBold18pt7b);
  display.setTextColor(BUTTON_TEXT_COLOR);
  display.setCursor(130, 630);
  display.print("BEGIN");
  display.setCursor(125, 660);
  display.print("HOMING");
  
  // BACK button (bottom left)
  display.setFont(&FreeSans9pt7b);
  display.fillRoundRect(40, 700, 120, 70, 10, CANCEL_COLOR);
  display.setTextColor(BUTTON_TEXT_COLOR);
  display.setCursor(70, 745);
  display.print("BACK");
  
  // HOME button (bottom right)
  display.fillRoundRect(320, 700, 120, 70, 10, CLEAR_COLOR);
  display.setTextColor(BUTTON_TEXT_COLOR);
  display.setCursor(345, 745);
  display.print("HOME");
}

void drawWaitingForSyringesPage() {
  display.fillScreen(BG_COLOR);
  display.setFont(&FreeSansBold18pt7b);
  display.setTextColor(TEXT_COLOR);
  display.setCursor(40, 150);
  display.print("LOAD SYRINGES");
  
  display.setFont(&FreeSans9pt7b);
  display.setCursor(50, 230);
  display.setTextColor(CONFIRM_COLOR);
  display.print("Motors at loading position!");
  display.setTextColor(TEXT_COLOR);
  display.setCursor(50, 260);
  display.print("(12000 steps)");
  
  display.setCursor(50, 330);
  display.print("Now:");
  display.setCursor(50, 365);
  display.print("1. Insert syringes");
  display.setCursor(50, 395);
  display.print("2. Fill with material");
  display.setCursor(50, 425);
  display.print("3. Secure in holders");
  
  display.setCursor(50, 490);
  display.print("Target volumes:");
  if (selectedVol1 > 0 && selectedVol2 > 0) {
    display.setCursor(50, 520);
    display.print("M1: ");
    display.print(selectedVol1, 1);
    display.print("mL (");
    display.print(mlToSteps(selectedVol1));
    display.print(" steps)");
    display.setCursor(50, 550);
    display.print("M2: ");
    display.print(selectedVol2, 1);
    display.print("mL (");
    display.print(mlToSteps(selectedVol2));
    display.print(" steps)");
  } else {
    display.setCursor(50, 520);
    display.print("M1: 10.0 mL (11750)");
    display.setCursor(50, 550);
    display.print("M2: 10.0 mL (11750)");
  }
  
  // SYRINGES LOADED button (center)
  display.fillRoundRect(90, 600, 300, 80, 10, CONFIRM_COLOR);
  display.setFont(&FreeSansBold18pt7b);
  display.setTextColor(BUTTON_TEXT_COLOR);
  display.setCursor(110, 650);
  display.print("SYRINGES");
  display.setCursor(145, 680);
  display.print("LOADED");
  
  // HOME button (bottom center)
  display.setFont(&FreeSans9pt7b);
  display.fillRoundRect(170, 710, 140, 60, 10, CLEAR_COLOR);
  display.setTextColor(BUTTON_TEXT_COLOR);
  display.setCursor(205, 748);
  display.print("HOME");
}

void drawHomePage() {
  display.fillScreen(BG_COLOR);
  display.setTextColor(TEXT_COLOR);
  display.setFont(&FreeSansBold12pt7b);
  display.setCursor(35, 50);
  display.print("PARAMETER CONTROL");
  
  // Draw parameter buttons vertically stacked - portrait 480x800
  drawHomeButton(40, 120, "Temperature", selectedTemp, "C");
  drawHomeButton(40, 230, "Volume 1", selectedVol1, "mL");
  drawHomeButton(40, 340, "Volume 2", selectedVol2, "mL");
  drawHomeButton(40, 450, "Concentration", selectedConc, "%");
  drawHomeButton(40, 560, "Speed", selectedSpeed, "mm/s");
  
  // Draw CONTINUE button at bottom
  display.fillRoundRect(140, 690, 200, 80, 8, CONFIRM_COLOR);
  display.setFont(&FreeSansBold18pt7b);
  display.setTextColor(TEXT_COLOR);
  display.setCursor(150, 740);
  display.print("CONTINUE");
}

void drawHomeButton(int x, int y, const char* label, float value, const char* unit) {
  // Draw button
  display.fillRoundRect(x, y, 400, 90, 8, BUTTON_COLOR);
  
  // Label with bold font
  display.setFont(&FreeSansBold12pt7b);
  display.setTextColor(BUTTON_TEXT_COLOR);
  display.setCursor(x + 15, y + 30);
  display.print(label);
  
  // Status with regular font
  display.setFont(&FreeSans9pt7b);
  display.setCursor(x + 15, y + 65);
  if (value < 0) {
    display.print("Not Selected");
  } else {
    display.print("Selected: ");
    
    // Special formatting for concentration
    if (unit[0] == '%') {
      float inverse = 100 - value;
      display.print(value, 1);
      display.print(":");
      display.print(inverse, 1);
      display.print("%");
    } else {
      display.print(value, 1);
      display.print(" ");
      if (unit[0] == 'C') {
        display.write(248); // Degree symbol
      }
      display.print(unit);
    }
  }
}

void drawParameterPage(int* options, int numOptions, float currentValue, const char* title, const char* unit) {
  display.fillScreen(BG_COLOR);
  display.setTextColor(TEXT_COLOR);
  display.setFont(&FreeSansBold12pt7b);
  display.setCursor(50, 40);
  display.print("Select ");
  display.print(title);
  display.print(":");
  
  // Draw white display box showing current selection with +/- buttons
  int boxX = 40;
  int boxY = 75;
  int boxWidth = 260;
  int boxHeight = 100;
  int buttonSize = 70;
  int buttonSpacing = 10;
  
  // Draw - button (left)
  display.fillRoundRect(boxX, boxY, buttonSize, boxHeight, 8, CONFIRM_COLOR);
  display.setFont(&FreeSansBold18pt7b);
  display.setTextColor(BUTTON_TEXT_COLOR);
  display.setCursor(boxX + 28, boxY + 62);
  display.print("-");
  
  // Draw display box (center)
  display.fillRoundRect(boxX + buttonSize + buttonSpacing, boxY, boxWidth, boxHeight, 8, BUTTON_COLOR);
  display.setFont(&FreeSansBold18pt7b);
  display.setTextColor(BUTTON_TEXT_COLOR);
  
  // Display current selection in the box
  if (tempSelection < 0) {
    display.setCursor(boxX + buttonSize + buttonSpacing + 45, boxY + 62);
    display.print("Not Set");
  } else {
    String valueStr = "";
    
    // Special formatting for concentration
    if (unit[0] == '%') {
      float inverse = 100 - tempSelection;
      valueStr = String(tempSelection, 0) + ":" + String(inverse, 0) + "%";
      int charCount = valueStr.length();
      int textWidth = charCount * 18;
      int textX = boxX + buttonSize + buttonSpacing + (boxWidth / 2) - (textWidth / 2);
      display.setCursor(textX, boxY + 62);
      display.print(valueStr);
    } else if (unit[0] == 'C') {
      int charCount = String(tempSelection, 1).length() + 2;
      int textWidth = charCount * 18;
      int textX = boxX + buttonSize + buttonSpacing + (boxWidth / 2) - (textWidth / 2);
      display.setCursor(textX, boxY + 62);
      display.print(tempSelection, 1);
      display.print(" ");
      display.write(248); // Degree symbol
      display.print(unit);
    } else {
      valueStr = String(tempSelection, 1) + " " + unit;
      int charCount = valueStr.length();
      int textWidth = charCount * 18;
      int textX = boxX + buttonSize + buttonSpacing + (boxWidth / 2) - (textWidth / 2);
      display.setCursor(textX, boxY + 62);
      display.print(valueStr);
    }
  }
  
  // Draw + button (right)
  display.fillRoundRect(boxX + buttonSize + buttonSpacing + boxWidth + buttonSpacing, boxY, buttonSize, boxHeight, 8, CONFIRM_COLOR);
  display.setFont(&FreeSansBold18pt7b);
  display.setTextColor(BUTTON_TEXT_COLOR);
  display.setCursor(boxX + buttonSize + buttonSpacing + boxWidth + buttonSpacing + 24, boxY + 62);
  display.print("+");
  
  // Draw option buttons - 3 columns for portrait
  int cols = 3;
  int buttonWidth = 120;
  int buttonHeight = 80;
  int spacingX = 20;
  int spacingY = 20;
  int startX = 40;
  int startY = 200;
  
  for (int i = 0; i < numOptions; i++) {
    int row = i / cols;
    int col = i % cols;
    int bx = startX + col * (buttonWidth + spacingX);
    int by = startY + row * (buttonHeight + spacingY);
    
    bool isSelected = (abs(options[i] - tempSelection) < 0.01);
    uint16_t bgColor = isSelected ? BUTTON_SELECTED_COLOR : BUTTON_COLOR;
    
    display.fillRoundRect(bx, by, buttonWidth, buttonHeight, 8, bgColor);
    display.setFont(&FreeSansBold18pt7b);
    display.setTextColor(BUTTON_TEXT_COLOR);
    
    // Center text in button
    String valueStr = String(options[i]);
    int charCount = valueStr.length();
    int textWidth = charCount * 20;
    int textX = bx + (buttonWidth - textWidth) / 2;
    int textY = by + 52;
    
    display.setCursor(textX, textY);
    display.print(options[i]);
  }
  
  // Draw BACK button (bottom left)
  display.fillRoundRect(40, 700, 120, 70, 8, CANCEL_COLOR);
  display.setFont(&FreeSansBold12pt7b);
  display.setTextColor(BUTTON_TEXT_COLOR);
  display.setCursor(65, 745);
  display.print("BACK");
  
  // Draw HOME button (bottom left of center)
  display.fillRoundRect(180, 700, 120, 70, 8, CLEAR_COLOR);
  display.setTextColor(BUTTON_TEXT_COLOR);
  display.setCursor(205, 745);
  display.print("HOME");
  
  // Draw CONFIRM button (bottom right)
  display.fillRoundRect(320, 700, 120, 70, 8, CONFIRM_COLOR);
  display.setTextColor(BUTTON_TEXT_COLOR);
  display.setCursor(330, 745);
  display.print("CONFIRM");
}


void drawPrintConfirmPage() {
  display.fillScreen(BG_COLOR);
  display.setTextColor(TEXT_COLOR);
  display.setFont(&FreeSansBold18pt7b);
  display.setCursor(80, 50);
  display.print("Begin Print?");
  
  // Draw parameter summary with bigger font
  int yPos = 130;
  int lineHeight = 90;
  
  // Temperature
  drawParameterSummary(40, yPos, "Temperature:", selectedTemp, "C");
  yPos += lineHeight;
  
  // Volume 1
  drawParameterSummary(40, yPos, "Volume 1:", selectedVol1, "mL");
  yPos += lineHeight;
  
  // Volume 2
  drawParameterSummary(40, yPos, "Volume 2:", selectedVol2, "mL");
  yPos += lineHeight;
  
  // Concentration
  drawParameterSummary(40, yPos, "Concentration:", selectedConc, "%");
  yPos += lineHeight;
  
  // Speed
  drawParameterSummary(40, yPos, "Speed:", selectedSpeed, "mm/s");
  
  // Draw CONFIRM button (center)
  display.fillRoundRect(140, 630, 200, 70, 8, CONFIRM_COLOR);
  display.setFont(&FreeSansBold12pt7b);
  display.setTextColor(BUTTON_TEXT_COLOR);
  display.setCursor(170, 675);
  display.print("CONFIRM");
  
  // Draw BACK button (bottom left)
  display.fillRoundRect(40, 720, 120, 50, 8, CANCEL_COLOR);
  display.setFont(&FreeSans9pt7b);
  display.setTextColor(BUTTON_TEXT_COLOR);
  display.setCursor(70, 753);
  display.print("BACK");
  
  // Draw HOME button (bottom right)
  display.fillRoundRect(320, 720, 120, 50, 8, CLEAR_COLOR);
  display.setTextColor(BUTTON_TEXT_COLOR);
  display.setCursor(345, 753);
  display.print("HOME");
}

void drawParameterSummary(int x, int y, const char* label, float value, const char* unit) {
  display.setFont(&FreeSansBold12pt7b);
  display.setTextColor(TEXT_COLOR);
  display.setCursor(x, y);
  display.print(label);
  
  display.setFont(&FreeSansBold12pt7b);
  display.setCursor(x, y + 40);
  if (value < 0) {
    display.print("Not Selected");
  } else {
    // Special formatting for concentration
    if (unit[0] == '%') {
      float inverse = 100 - value;
      display.print(value, 1);
      display.print(":");
      display.print(inverse, 1);
      display.print("%");
    } else {
      display.print(value, 1);
      display.print(" ");
      if (unit[0] == 'C') {
        display.write(248); // Degree symbol
      }
      display.print(unit);
    }
  }
}

void drawLoadingPage() {
  display.fillScreen(BG_COLOR);
  display.setFont(&FreeSansBold18pt7b);
  display.setTextColor(TEXT_COLOR);
  display.setCursor(80, 150);
  display.print("LOADING...");
  
  display.setFont(&FreeSans9pt7b);
  
  // Current Syringe Temperature (A2/A3 average)
  display.setCursor(50, 200);
  display.print("Syringe Temperature:");
  display.setFont(&FreeSansBold12pt7b);
  display.setCursor(50, 235);
  if (currentDisplayTemp > -999.0) {
    display.print(currentDisplayTemp, 1);
    display.print(" C / ");
    display.print(Setpoint_Syringe, 0);
    display.print(" C");
  } else {
    display.print("--- C");
  }
  
  // Heat Mat Temperature
  display.setFont(&FreeSans9pt7b);
  display.setCursor(50, 280);
  display.print("Heat Mat Temperature:");
  display.setFont(&FreeSansBold12pt7b);
  display.setCursor(50, 315);
  if (Input_HeatMat > -999.0) {
    display.print(Input_HeatMat, 1);
    display.print(" C / 80 C");
  } else {
    display.print("--- C");
  }
  
  // PWM Output Comparison
  display.setFont(&FreeSans9pt7b);
  display.setCursor(50, 370);
  display.print("PWM Values:");
  display.setCursor(50, 400);
  display.print("Heat Mat PID: ");
  display.print((Output_HeatMat / 255.0) * 100.0, 1);
  display.print("%");
  display.setCursor(50, 430);
  display.print("Syringe PID: ");
  display.print((Output_Syringe / 255.0) * 100.0, 1);
  display.print("%");
  
  // Active control phase
  display.setCursor(50, 470);
  display.setTextColor(CONFIRM_COLOR);
  if (!syringesTempReached) {
    display.print("Phase 1: Heating to 80C");
  } else {
    display.print("Phase 2: Modulating");
  }
  display.setTextColor(TEXT_COLOR);
  
  // Sensor details
  display.setCursor(50, 520);
  display.print("A0:");
  display.print(currentTemperatures[0], 1);
  display.print(" A1:");
  display.print(currentTemperatures[1], 1);
  
  display.setCursor(50, 550);
  display.print("A2:");
  display.print(currentTemperatures[2], 1);
  display.print(" A3:");
  display.print(currentTemperatures[3], 1);
  
  display.setCursor(120, 600);
  display.print(state_names[current_state]);
  
  // Home button
  display.fillRoundRect(140, 680, 200, 80, 10, CANCEL_COLOR);
  display.setTextColor(BUTTON_TEXT_COLOR);
  display.setCursor(185, 730);
  display.print("HOME");
}

void drawTempReadyPage() {
  display.fillScreen(BG_COLOR);
  display.setFont(&FreeSansBold18pt7b);
  display.setTextColor(TEXT_COLOR);
  display.setCursor(80, 120);
  display.print("READY?");
  
  display.setFont(&FreeSans9pt7b);
  
  // Current Syringe Temperature (A2/A3 average)
  display.setCursor(50, 200);
  display.print("Syringe Temperature:");
  display.setFont(&FreeSansBold12pt7b);
  display.setCursor(50, 240);
  if (currentDisplayTemp > -999.0) {
    display.print(currentDisplayTemp, 1);
    display.print(" C / ");
    display.print(Setpoint_Syringe, 0);
    display.print(" C");
  } else {
    display.print("--- C");
  }
  
  // Heat Mat Temperature
  display.setFont(&FreeSans9pt7b);
  display.setCursor(50, 290);
  display.print("Heat Mat: ");
  if (Input_HeatMat > -999.0) {
    display.print(Input_HeatMat, 1);
    display.print(" C");
  } else {
    display.print("--- C");
  }
  
  // Status message
  display.setFont(&FreeSans9pt7b);
  display.setCursor(50, 350);
  
  if (systemReady) {
    display.setTextColor(CONFIRM_COLOR);
    display.print("Temperature reached!");
    display.setTextColor(TEXT_COLOR);
    display.setCursor(50, 380);
    display.print("Actuators initialized");
    display.setCursor(50, 410);
    display.print("Motors homed");
  } else {
    display.print("Waiting for:");
    int yPos = 380;
    if (abs(currentDisplayTemp - Setpoint_Syringe) > TEMP_TOLERANCE) {
      display.setCursor(50, yPos);
      display.print("- Syringe temperature");
      yPos += 30;
    }
    if (current_state != PRIMED) {
      display.setCursor(50, yPos);
      display.print("- Actuator initialization");
      yPos += 30;
    }
    if (!motorsHomed) {
      display.setCursor(50, yPos);
      display.setTextColor(CANCEL_COLOR);
      display.print("- MOTOR HOMING REQUIRED!");
      display.setTextColor(TEXT_COLOR);
      display.setCursor(50, yPos + 25);
      display.print("  (Press HOME on welcome page)");
    }
  }
  
  // System details
  display.setCursor(50, 510);
  display.print("A0=");
  display.print(currentTemperatures[0], 1);
  display.print(" A1=");
  display.print(currentTemperatures[1], 1);
  
  display.setCursor(50, 540);
  display.print("A2=");
  display.print(currentTemperatures[2], 1);
  display.print(" A3=");
  display.print(currentTemperatures[3], 1);
  
  // YES button (only if ready)
  if (systemReady) {
    display.fillRoundRect(90, 600, 300, 80, 10, CONFIRM_COLOR);
    display.setFont(&FreeSansBold18pt7b);
    display.setTextColor(BUTTON_TEXT_COLOR);
    display.setCursor(180, 655);
    display.print("YES");
  }
  
  // HOME button
  display.setFont(&FreeSans9pt7b);
  display.fillRoundRect(140, 700, 200, 60, 10, CANCEL_COLOR);
  display.setTextColor(BUTTON_TEXT_COLOR);
  display.setCursor(190, 740);
  display.print("HOME");
}

void drawReadyToPrintPage() {
  display.fillScreen(BG_COLOR);
  display.setFont(&FreeSansBold18pt7b);
  display.setTextColor(TEXT_COLOR);
  display.setCursor(60, 100);
  display.print("READY!");
  
  display.setFont(&FreeSans9pt7b);
  
  // Temperature info
  display.setCursor(50, 180);
  display.print("Temperature: ");
  display.print(Input_Syringe, 1);
  display.print(" / ");
  display.print(Setpoint_Syringe, 0);
  display.print(" C");
  
  // Volume info
  display.setCursor(50, 230);
  display.print("Remaining:");
  display.setCursor(50, 260);
  display.print("M1: ");
  display.print(config.remaining1, 2);
  display.print(" mL");
  display.setCursor(50, 290);
  display.print("M2: ");
  display.print(config.remaining2, 2);
  display.print(" mL");
  
  display.setCursor(50, 340);
  display.print("Dispensed:");
  display.setCursor(50, 370);
  display.print("M1: ");
  display.print(config.dispensed1, 2);
  display.print(" mL");
  display.setCursor(50, 400);
  display.print("M2: ");
  display.print(config.dispensed2, 2);
  display.print(" mL");
  
  // PRINT button
  display.fillRoundRect(90, 500, 300, 120, 10, CONFIRM_COLOR);
  display.setFont(&FreeSansBold18pt7b);
  display.setTextColor(BUTTON_TEXT_COLOR);
  display.setCursor(155, 575);
  display.print("PRINT");
  
  // HOME button
  display.setFont(&FreeSans9pt7b);
  display.fillRoundRect(140, 670, 200, 70, 10, CANCEL_COLOR);
  display.setCursor(190, 715);
  display.print("HOME");
}

void drawPrintingPage() {
  display.fillScreen(BG_COLOR);
  display.setFont(&FreeSansBold18pt7b);
  display.setTextColor(TEXT_COLOR);
  display.setCursor(80, 100);
  display.print("PRINTING");
  
  display.setFont(&FreeSans9pt7b);
  
  // Current Temperature
  display.setCursor(50, 160);
  display.print("Current Temperature:");
  display.setFont(&FreeSansBold12pt7b);
  display.setCursor(50, 195);
  if (currentDisplayTemp > -999.0) {
    display.print(currentDisplayTemp, 1);
    display.print(" C");
  } else {
    display.print("--- C");
  }
  
  // Selected Temperature
  display.setFont(&FreeSans9pt7b);
  display.setCursor(50, 235);
  display.print("Selected Temperature:");
  display.setFont(&FreeSansBold12pt7b);
  display.setCursor(50, 270);
  display.print(Setpoint_Syringe, 1);
  display.print(" C");
  
  // Remaining volumes
  display.setFont(&FreeSans9pt7b);
  display.setCursor(50, 320);
  display.print("Remaining:");
  display.setCursor(50, 350);
  display.print("M1: ");
  display.print(config.remaining1, 2);
  display.print(" mL");
  display.setCursor(50, 380);
  display.print("M2: ");
  display.print(config.remaining2, 2);
  display.print(" mL");
  
  // Dispensed volumes
  display.setCursor(50, 430);
  display.print("Dispensed:");
  display.setCursor(50, 460);
  display.print("M1: ");
  display.print(config.dispensed1, 2);
  display.print(" mL");
  display.setCursor(50, 490);
  display.print("M2: ");
  display.print(config.dispensed2, 2);
  display.print(" mL");
  
  // Progress indicator
  float progress1 = (config.dispensed1 / config.syringe_vol1) * 100.0;
  display.setCursor(50, 530);
  display.print("Progress: ");
  display.print(progress1, 0);
  display.print(" %");
  
  // EMERGENCY STOP button
  display.fillRoundRect(140, 600, 200, 80, 10, CANCEL_COLOR);
  display.setFont(&FreeSansBold12pt7b);
  display.setTextColor(BUTTON_TEXT_COLOR);
  display.setCursor(165, 650);
  display.print("STOP");
}

void drawPrintDonePage() {
  display.fillScreen(BG_COLOR);
  display.setFont(&FreeSansBold18pt7b);
  display.setTextColor(CONFIRM_COLOR);
  display.setCursor(60, 200);
  display.print("PRINT DONE!");
  
  display.setFont(&FreeSans9pt7b);
  display.setTextColor(TEXT_COLOR);
  
  display.setCursor(80, 300);
  display.print("Total Dispensed:");
  display.setCursor(80, 340);
  display.print("M1: ");
  display.print(config.dispensed1, 2);
  display.print(" mL");
  display.setCursor(80, 370);
  display.print("M2: ");
  display.print(config.dispensed2, 2);
  display.print(" mL");
  
  display.setCursor(80, 430);
  display.print("Final Temperature:");
  display.setCursor(80, 460);
  display.print(currentDisplayTemp, 1);
  display.print(" C");
  
  // HOME button
  display.fillRoundRect(140, 550, 200, 80, 10, CONFIRM_COLOR);
  display.setFont(&FreeSansBold18pt7b);
  display.setTextColor(BUTTON_TEXT_COLOR);
  display.setCursor(185, 605);
  display.print("HOME");
}

void drawErrorPage(const char* message) {
  display.fillScreen(BG_COLOR);
  display.setFont(&FreeSansBold18pt7b);
  display.setTextColor(CANCEL_COLOR);
  display.setCursor(100, 200);
  display.print("ERROR");
  
  display.setFont(&FreeSans9pt7b);
  display.setTextColor(TEXT_COLOR);
  display.setCursor(80, 300);
  display.print(message);
  
  display.fillRoundRect(165, 450, 150, 70, 10, BUTTON_COLOR);
  display.setTextColor(BUTTON_TEXT_COLOR);
  display.setCursor(205, 495);
  display.print("HOME");
}

// ==================== TOUCH HANDLERS ====================
void handleWelcomeTouch(int x, int y) {
  // START button
  if (x >= 140 && x <= 340 && y >= 630 && y <= 730) {
    currentPage = HOME;
    drawHomePage();
  }
}

void handleHomeTouch(int x, int y) {
  if (x >= 40 && x <= 440) {
    if (y >= 120 && y <= 210) {
      currentPage = TEMPERATURE_PAGE;
      tempSelection = selectedTemp;
      drawParameterPage(tempOptions, numTempOptions, tempSelection, "Temperature", "C");
    } else if (y >= 230 && y <= 320) {
      currentPage = VOLUME1;
      tempSelection = selectedVol1;
      drawParameterPage(volOptions, numVolOptions, tempSelection, "Volume 1", "mL");
    } else if (y >= 340 && y <= 430) {
      currentPage = VOLUME2;
      tempSelection = selectedVol2;
      drawParameterPage(volOptions, numVolOptions, tempSelection, "Volume 2", "mL");
    } else if (y >= 450 && y <= 540) {
      currentPage = CONCENTRATION;
      tempSelection = selectedConc;
      drawParameterPage(concOptions, numConcOptions, tempSelection, "Concentration", "%");
    } else if (y >= 560 && y <= 650) {
      currentPage = SPEED;
      tempSelection = selectedSpeed;
      drawParameterPage(speedOptions, numSpeedOptions, tempSelection, "Speed", "mm/s");
    }
  }
  
  // Check CONTINUE button
  if (x >= 140 && x <= 340 && y >= 690 && y <= 770) {
    // Check if all parameters are selected
    if (selectedTemp < 0 || selectedVol1 < 0 || selectedVol2 < 0 || 
        selectedConc < 0 || selectedSpeed < 0) {
      Serial.println("Error: Not all parameters selected");
      currentPage = ERROR_PAGE;
      drawErrorPage("Please specify all parameters");
    } else {
      Serial.println("All parameters selected, going to syringe loading page");
      // Just go to the loading page, don't automatically home
      currentPage = LOADING_SYRINGES;
      drawLoadingSyringesPage();
    }
  }
}

void handleParameterTouch(int x, int y, int* options, int numOptions, float* targetVar) {
  // +/- button handling
  int boxX = 40;
  int boxY = 75;
  int boxWidth = 260;
  int boxHeight = 100;
  int buttonSize = 70;
  int buttonSpacing = 10;
  
  // Determine step size based on page
  float step = 1.0f;  // Default
  float minVal = 0;
  float maxVal = 100;
  
  if (currentPage == TEMPERATURE_PAGE) {
    step = 1.0f;  // 1°C increment
    minVal = tempOptions[0];
    maxVal = tempOptions[numTempOptions - 1];
  } else if (currentPage == VOLUME1 || currentPage == VOLUME2) {
    step = 0.1f;  // 0.1 mL increment
    minVal = 0.1f;
    maxVal = 10.0f;
  } else if (currentPage == CONCENTRATION) {
    step = 5.0f;  // 5% increment
    minVal = concOptions[0];
    maxVal = concOptions[numConcOptions - 1];
  } else if (currentPage == SPEED) {
    step = 0.1f;  // 0.1 mm/s increment
    minVal = speedOptions[0];
    maxVal = speedOptions[numSpeedOptions - 1];
  }
  
  // Check - button (decrease)
  if (x >= boxX && x <= boxX + buttonSize && y >= boxY && y <= boxY + boxHeight) {
    if (tempSelection >= 0) {
      tempSelection -= step;
      if (tempSelection < minVal) tempSelection = minVal;
      // Round to appropriate decimal places
      if (step < 1.0f) {
        tempSelection = round(tempSelection * 10.0) / 10.0;
      } else {
        tempSelection = round(tempSelection);
      }
      const char* title;
      const char* unit;
      getCurrentPageInfo(&title, &unit);
      drawParameterPage(options, numOptions, tempSelection, title, unit);
    }
    return;
  }
  
  // Check + button (increase)
  int plusX = boxX + buttonSize + buttonSpacing + boxWidth + buttonSpacing;
  if (x >= plusX && x <= plusX + buttonSize && y >= boxY && y <= boxY + boxHeight) {
    if (tempSelection >= 0) {
      tempSelection += step;
      if (tempSelection > maxVal) tempSelection = maxVal;
      // Round to appropriate decimal places
      if (step < 1.0f) {
        tempSelection = round(tempSelection * 10.0) / 10.0;
      } else {
        tempSelection = round(tempSelection);
      }
      const char* title;
      const char* unit;
      getCurrentPageInfo(&title, &unit);
      drawParameterPage(options, numOptions, tempSelection, title, unit);
    } else {
      // If not set, start with first option
      tempSelection = options[0];
      const char* title;
      const char* unit;
      getCurrentPageInfo(&title, &unit);
      drawParameterPage(options, numOptions, tempSelection, title, unit);
    }
    return;
  }
  
  // Check BACK button (bottom left)
  if (x >= 40 && x <= 160 && y >= 700 && y <= 770) {
    currentPage = HOME;
    drawHomePage();
    return;
  }
  
  // Check HOME button (bottom center-left)
  if (x >= 180 && x <= 300 && y >= 700 && y <= 770) {
    currentPage = WELCOME;
    drawWelcomePage();
    return;
  }
  
  // Check CONFIRM button (bottom right)
  if (x >= 320 && x <= 440 && y >= 700 && y <= 770) {
    if (currentPage == TEMPERATURE_PAGE && tempSelection > 0) {
      selectedTemp = tempSelection;
      Setpoint_Syringe = selectedTemp;
      Serial.print("Syringe temperature setpoint updated: ");
      Serial.print(Setpoint_Syringe);
      Serial.println(" C");
    } else if (tempSelection >= 0) {
      *targetVar = tempSelection;
    }
    currentPage = HOME;
    drawHomePage();
    return;
  }
  
  // Option button grid - 3 columns
  int cols = 3;
  int buttonWidth = 120;
  int buttonHeight = 80;
  int spacingX = 20;
  int spacingY = 20;
  int startX = 40;
  int startY = 200;
  
  for (int i = 0; i < numOptions; i++) {
    int col = i % cols;
    int row = i / cols;
    int bx = startX + col * (buttonWidth + spacingX);
    int by = startY + row * (buttonHeight + spacingY);
    
    if (x >= bx && x <= bx + buttonWidth && y >= by && y <= by + buttonHeight) {
      tempSelection = options[i];
      const char* title;
      const char* unit;
      getCurrentPageInfo(&title, &unit);
      drawParameterPage(options, numOptions, tempSelection, title, unit);
      break;
    }
  }
}

void handlePrintConfirmTouch(int x, int y) {
  if (x >= 140 && x <= 340 && y >= 630 && y <= 700) {
    Serial.println("Confirm - starting print sequence");
    
    // Enable heat control with selected temperature
    Setpoint_Syringe = selectedTemp;
    heatControlEnabled = true;
    systemReady = false;
    Serial.print("Heat control enabled - Syringe Target: ");
    Serial.print(Setpoint_Syringe);
    Serial.println(" C, Heat Mat Target: 80 C");
    
    currentPage = LOADING_PAGE;
    drawLoadingPage();
    delay(500);
    
    // Step 1: Load motors
    if (!executeLoad()) {
      drawErrorPage("Load failed");
      currentPage = ERROR_PAGE;
      return;
    }
    drawLoadingPage();
    delay(500);
    
    // Step 2: Setup with selected parameters
    if (!executeSetup(selectedVol1, selectedVol2, selectedConc)) {
      drawErrorPage("Setup failed");
      currentPage = ERROR_PAGE;
      return;
    }
    drawLoadingPage();
    delay(500);
    
    // Step 3: Prime motors
    if (!executePrime()) {
      drawErrorPage("Prime failed");
      currentPage = ERROR_PAGE;
      return;
    }
    drawLoadingPage();
    delay(500);
    
    // Go to temperature ready page - wait for stabilization
    currentPage = TEMP_READY;
    tempStableTime = 0;
    systemReady = false;  // Reset ready flag
    drawTempReadyPage();
    Serial.println("Waiting for temperature stabilization and motor homing...");
  }
  
  // Check BACK button - just go back to loading page, don't re-home
  if (x >= 40 && x <= 160 && y >= 720 && y <= 770) {
    Serial.println("Back to syringe loading page");
    currentPage = LOADING_SYRINGES;
    drawLoadingSyringesPage();
  }
  
  // Check HOME button
  if (x >= 320 && x <= 440 && y >= 720 && y <= 770) {
    Serial.println("Going home");
    currentPage = WELCOME;
    drawWelcomePage();
  }
}

void handleTempReadyTouch(int x, int y) {
  // Check YES button (only active when systemReady)
  if (x >= 90 && x <= 390 && y >= 600 && y <= 680 && systemReady) {
    Serial.println("YES button pressed - proceeding to print");
    currentPage = READY_TO_PRINT;
    drawReadyToPrintPage();
  }
  
  // Check HOME button
  if (x >= 140 && x <= 340 && y >= 700 && y <= 760) {
    // Turn off heat when going home
    heatControlEnabled = false;
    analogWrite(MOSFET_PIN, 0);
    Serial.println("Heat control disabled");
    currentPage = HOME;
    drawHomePage();
  }
}

void handleReadyToPrintTouch(int x, int y) {
  // Check PRINT button
  if (x >= 90 && x <= 390 && y >= 500 && y <= 620) {
    Serial.println("PRINT button pressed - starting continuous extrusion");
    isPrinting = true;
    currentPage = PRINTING_PAGE;
    drawPrintingPage();
  }
  
  // Check HOME button
  if (x >= 140 && x <= 340 && y >= 670 && y <= 740) {
    // Turn off heat when going home
    heatControlEnabled = false;
    analogWrite(MOSFET_PIN, 0);
    Serial.println("Heat control disabled");
    currentPage = HOME;
    drawHomePage();
  }
}

void handlePrintingTouch(int x, int y) {
  // Check STOP button
  if (x >= 140 && x <= 340 && y >= 600 && y <= 680) {
    Serial.println("EMERGENCY STOP button pressed");
    isPrinting = false;
    
    // Immediately halt motors
    tic1.haltAndHold();
    tic2.haltAndHold();
    delay(100);
    
    // Read actual positions where motors stopped
    long stopped_pos1 = tic1.getCurrentPosition();
    long stopped_pos2 = tic2.getCurrentPosition();
    
    // Update Arduino tracker
    arduino_pos1 = stopped_pos1;
    arduino_pos2 = stopped_pos2;
    
    // Update remaining volumes based on where we actually stopped
    // Calculate how much was actually dispensed from the prime position
    float actualDispensed1 = (config.prime_pos1 - arduino_pos1) / STEPS_PER_ML;
    float actualDispensed2 = (config.prime_pos2 - arduino_pos2) / STEPS_PER_ML;
    
    config.remaining1 = config.syringe_vol1 - actualDispensed1;
    config.remaining2 = config.syringe_vol2 - actualDispensed2;
    config.dispensed1 = actualDispensed1;
    config.dispensed2 = actualDispensed2;
    
    Serial.print("Stopped at positions - M1: ");
    Serial.print(arduino_pos1);
    Serial.print(" (");
    Serial.print(stepsToMl(arduino_pos1), 2);
    Serial.print("mL), M2: ");
    Serial.print(arduino_pos2);
    Serial.print(" (");
    Serial.print(stepsToMl(arduino_pos2), 2);
    Serial.println("mL)");
    Serial.print("Remaining - M1: ");
    Serial.print(config.remaining1);
    Serial.print(" mL, M2: ");
    Serial.print(config.remaining2);
    Serial.println(" mL");
    
    current_state = COMPLETE;
    currentPage = READY_TO_PRINT;
    drawReadyToPrintPage();
  }
}

void handleLoadingTouch(int x, int y) {
  if (x >= 140 && x <= 340 && y >= 680 && y <= 760) {
    // Turn off heat when going home
    heatControlEnabled = false;
    analogWrite(MOSFET_PIN, 0);
    Serial.println("Heat control disabled");
    currentPage = HOME;
    drawHomePage();
  }
}

void handlePrintDoneTouch(int x, int y) {
  if (x >= 140 && x <= 340 && y >= 550 && y <= 630) {
    // Turn off heat when done
    heatControlEnabled = false;
    analogWrite(MOSFET_PIN, 0);
    Serial.println("Print done - heat control disabled");
    currentPage = HOME;
    drawHomePage();
  }
}

void handleErrorTouch(int x, int y) {
  if (x >= 165 && x <= 315 && y >= 450 && y <= 520) {
    // Turn off heat when going home
    heatControlEnabled = false;
    analogWrite(MOSFET_PIN, 0);
    Serial.println("Heat control disabled");
    currentPage = HOME;
    drawHomePage();
  }
}

void handleLoadingSyringesTouch(int x, int y) {
  // Check BEGIN HOMING button
  if (x >= 90 && x <= 390 && y >= 580 && y <= 660) {
    Serial.println("BEGIN HOMING button pressed - starting homing process");
    currentPage = HOMING_PAGE;
    drawHomingPage();
    delay(500);
    
    // Move to load position (12000)
    if (!homeMotors()) {
      Serial.println("Failed to reach loading position!");
      drawErrorPage("Failed to reach loading position!");
      currentPage = ERROR_PAGE;
      return;
    }
    
    // Show waiting page where user loads syringes
    Serial.println("At loading position - waiting for user to load syringes");
    currentPage = WAITING_FOR_SYRINGES;
    drawWaitingForSyringesPage();
    
    return;
  }
  
  // Check BACK button
  if (x >= 40 && x <= 160 && y >= 700 && y <= 770) {
    Serial.println("Back to parameter selection");
    currentPage = HOME;
    drawHomePage();
  }
  
  // Check HOME button
  if (x >= 320 && x <= 440 && y >= 700 && y <= 770) {
    Serial.println("Going home");
    currentPage = WELCOME;
    drawWelcomePage();
  }
}

void handleWaitingForSyringesTouch(int x, int y) {
  // Check SYRINGES LOADED button
  if (x >= 90 && x <= 390 && y >= 600 && y <= 680) {
    Serial.println("SYRINGES LOADED button pressed - completing homing");
    currentPage = HOMING_PAGE;
    drawHomingPage();
    delay(500);
    
    if (completeHoming()) {
      Serial.println("Homing complete! Proceeding to print confirmation");
      currentPage = PRINT_CONFIRM;
      drawPrintConfirmPage();
    } else {
      Serial.println("Homing completion failed!");
      drawErrorPage("Homing completion failed!");
      currentPage = ERROR_PAGE;
    }
    return;
  }
  
  // Check HOME button
  if (x >= 170 && x <= 310 && y >= 710 && y <= 770) {
    Serial.println("Going home");
    currentPage = WELCOME;
    drawWelcomePage();
  }
}

void handleTouch(int x, int y) {
  switch (currentPage) {
    case WELCOME:
      handleWelcomeTouch(x, y);
      break;
    case HOME:
      handleHomeTouch(x, y);
      break;
    case TEMPERATURE_PAGE:
      handleParameterTouch(x, y, tempOptions, numTempOptions, &selectedTemp);
      break;
    case VOLUME1:
      handleParameterTouch(x, y, volOptions, numVolOptions, &selectedVol1);
      break;
    case VOLUME2:
      handleParameterTouch(x, y, volOptions, numVolOptions, &selectedVol2);
      break;
    case CONCENTRATION:
      handleParameterTouch(x, y, concOptions, numConcOptions, &selectedConc);
      break;
    case SPEED:
      handleParameterTouch(x, y, speedOptions, numSpeedOptions, &selectedSpeed);
      break;
    case PRINT_CONFIRM:
      handlePrintConfirmTouch(x, y);
      break;
    case LOADING_PAGE:
      handleLoadingTouch(x, y);
      break;
    case LOADING_SYRINGES:
      handleLoadingSyringesTouch(x, y);
      break;
    case WAITING_FOR_SYRINGES:
      handleWaitingForSyringesTouch(x, y);
      break;
    case TEMP_READY:
      handleTempReadyTouch(x, y);
      break;
    case READY_TO_PRINT:
      handleReadyToPrintTouch(x, y);
      break;
    case PRINTING_PAGE:
      handlePrintingTouch(x, y);
      break;
    case PRINT_DONE:
      handlePrintDoneTouch(x, y);
      break;
    case ERROR_PAGE:
      handleErrorTouch(x, y);
      break;
  }
}

void getCurrentPageInfo(const char** title, const char** unit) {
  if (currentPage == TEMPERATURE_PAGE) {
    *title = "Temperature";
    *unit = "C";
  } else if (currentPage == VOLUME1) {
    *title = "Volume 1";
    *unit = "mL";
  } else if (currentPage == VOLUME2) {
    *title = "Volume 2";
    *unit = "mL";
  } else if (currentPage == CONCENTRATION) {
    *title = "Concentration";
    *unit = "%";
  } else if (currentPage == SPEED) {
    *title = "Speed";
    *unit = "mm/s";
  }
}

// ==================== CONTINUOUS PRINTING ====================
void performContinuousPrint() {
  // Calculate how much can be extruded based on remaining volumes
  float maxVol1 = config.remaining1;
  float maxVol2 = config.remaining2 / (config.ratio2 / config.ratio1);
  float volumeToExtrude = min(maxVol1, maxVol2);
  
  // Extrude in small increments for better control
  float increment = 0.5; // 0.5mL at a time
  if (volumeToExtrude > increment) {
    volumeToExtrude = increment;
  }
  
  if (volumeToExtrude > 0.01) {
    if (executeExtrude(volumeToExtrude, selectedSpeed)) {
      drawPrintingPage();
    } else {
      // Extrusion failed or completed
      isPrinting = false;
      if (config.remaining1 < 0.1 || config.remaining2 < 0.1) {
        Serial.println("Print complete - volumes depleted");
        drawPrintDonePage();
        currentPage = PRINT_DONE;
      } else {
        Serial.println("Extrusion error");
        drawErrorPage("Extrusion error");
        currentPage = ERROR_PAGE;
      }
    }
  } else {
    // Not enough material left
    isPrinting = false;
    Serial.println("Print complete - volumes depleted");
    drawPrintDonePage();
    currentPage = PRINT_DONE;
  }
}

// ==================== SETUP ====================
void setup() {
  Serial.begin(115200);
  while (!Serial && millis() < 3000);
  
  delay(1000);
  
  Serial.println("\n================================");
  Serial.println("  BIOPRINT AM - UNIFIED v3.0");
  Serial.println("  + PID TEMPERATURE CONTROL");
  Serial.println("  + IMPROVED MOTOR CONTROL");
  Serial.println("================================");
  
  // Set ADC resolution for GIGA
  analogReadResolution(12);
  
  // Initialize heat control pin
  pinMode(MOSFET_PIN, OUTPUT);
  analogWrite(MOSFET_PIN, 0);
  
  display.begin();
  touchDetector.begin();
  display.setRotation(0);
  display.fillScreen(BG_COLOR);
  
  initializeMotors();
  updateTemperatures();
  
  Serial.println("System ready!");
  Serial.print("Initial temperatures - A0: ");
  Serial.print(currentTemperatures[0], 2);
  Serial.print(" C, A1: ");
  Serial.print(currentTemperatures[1], 2);
  Serial.println(" C");
  Serial.print("PID Kp (HeatMat) = ");
  Serial.print(Kp_HeatMat, 0);
  Serial.print(", Kp (Syringe) = ");
  Serial.println(Kp_Syringe, 0);
  
  drawWelcomePage();
}

// ==================== MAIN LOOP ====================
void loop() {
  // Update temperatures periodically
  if (millis() - lastTempUpdate > TEMP_UPDATE_INTERVAL) {
    updateTemperatures();
    lastTempUpdate = millis();
    
    if (currentPage == LOADING_PAGE) {
      drawLoadingPage();
    }
    
    // Check for temperature stabilization on TEMP_READY page
    if (currentPage == TEMP_READY) {
      bool tempStable = (currentDisplayTemp > -999.0) && 
                        (abs(currentDisplayTemp - Setpoint_Syringe) <= TEMP_TOLERANCE);
      bool actuatorsReady = (current_state == PRIMED) && motorsHomed;
      
      if (tempStable && actuatorsReady) {
        if (tempStableTime == 0) {
          tempStableTime = millis();
        } else if (millis() - tempStableTime >= TEMP_STABLE_DURATION) {
          if (!systemReady) {
            systemReady = true;
            Serial.println("System ready! Temperature stable and actuators initialized.");
            drawTempReadyPage();
          }
        }
      } else {
        tempStableTime = 0;
        if (systemReady) {
          systemReady = false;
          drawTempReadyPage();
        }
      }
      
      // Periodic update of TEMP_READY page
      static unsigned long lastTempReadyUpdate = 0;
      if (millis() - lastTempReadyUpdate > 2000) {
        drawTempReadyPage();
        lastTempReadyUpdate = millis();
      }
    }
  }
  
  // Apply PID heat control (runs continuously when enabled)
  applyHeatControl();
  
  // Handle continuous printing
  if (isPrinting && currentPage == PRINTING_PAGE) {
    performContinuousPrint();
  }
  
  // Handle touch input
  uint8_t contacts;
  GDTpoint_t points[5];
  contacts = touchDetector.getTouchPoints(points);
  
  if (contacts > 0 && !lastTouchState) {
    int x = points[0].x;
    int y = points[0].y;
    
    Serial.print("Touch at X: ");
    Serial.print(x);
    Serial.print(" Y: ");
    Serial.println(y);
    
    handleTouch(x, y);
    lastTouchState = true;
    delay(250);
  } else if (contacts == 0) {
    lastTouchState = false;
  }
  
  // Keep motors responsive
  if (current_state == EXTRUDING) {
    tic1.resetCommandTimeout();
    tic2.resetCommandTimeout();
  }
  
  delay(10);
}
