/*
 * BioPrint AM - Unified Control System
 * Arduino GIGA R1 WiFi
 * 
 * Integrates:
 * - Dual Syringe Controller (I2C Pololu TIC T825 stepper drivers)
 * - 4-Channel Thermistor Monitoring
 * - Touchscreen UI (GigaDisplay)
 * 
 * Hardware:
 * - Motors: Actuonix P8-ST-100mm (IDs 14 & 15)
 * - Thermistors: 4x on A0-A3
 * - Display: 480x800 touchscreen
 */

#include <Tic.h>
#include <Wire.h>
#include <math.h>
#include "Arduino_GigaDisplay_GFX.h"
#include "Arduino_GigaDisplayTouch.h"
#include <Fonts/FreeSansBold12pt7b.h>
#include <Fonts/FreeSans9pt7b.h>
#include <Fonts/FreeSansBold18pt7b.h>

// ==================== DISPLAY & TOUCH ====================
GigaDisplay_GFX display;
Arduino_GigaDisplayTouch touchDetector;

// Colors
#define BG_COLOR 0xFFFF
#define BUTTON_COLOR 0x0010
#define BUTTON_SELECTED_COLOR 0x4208
#define TEXT_COLOR 0x0010
#define BUTTON_TEXT_COLOR 0xFFFF
#define CONFIRM_COLOR 0xA9CF
#define CANCEL_COLOR 0xF800
#define CLEAR_COLOR 0xFD20

// ==================== MOTOR CONFIGURATION ====================
#define MOTOR1_ADDRESS 14
#define MOTOR2_ADDRESS 15

const float STEPS_PER_ML = 1000.0f;
const float MM_PER_STEP = 0.00605f;
const float MM_PER_ML = 6.05f;
const float MAX_VOLUME_ML = 12.0f;
const long LOAD_POSITION = 12000L;
const float MAX_SPEED_MMS = 3.0f;
const long MAX_SPEED_STEPS_S = 496L;
const int MAX_ACCEL = 1000;
const int POSITION_TOLERANCE = 10;

TicI2C tic1;
TicI2C tic2;

// ==================== THERMISTOR CONFIGURATION ====================
const int numThermistors = 4;
const int thermistorPins[numThermistors] = {A0, A1, A2, A3};
const float seriesResistor = 10000.0;
const float thermistorNominal = 10000.0;
const float temperatureNominal = 25.0;
const float betaCoefficient = 3950.0;

float currentTemperatures[numThermistors] = {-999, -999, -999, -999};
unsigned long lastTempUpdate = 0;
const unsigned long TEMP_UPDATE_INTERVAL = 1000; // Update every 1 second

// ==================== STATE MACHINE ====================
enum SystemState {
  UNINITIALIZED,
  LOAD,
  SETUP,
  PRIMED,
  READY,
  EXTRUDING,
  COMPLETE,
  SAFE_MODE
};

SystemState current_state = UNINITIALIZED;
const char* state_names[] = {"UNINITIALIZED", "LOAD", "SETUP", "PRIMED", "READY", "EXTRUDING", "COMPLETE", "SAFE_MODE"};

// ==================== UI PAGE DEFINITIONS ====================
enum Page {
  WELCOME,
  HOME,
  TEMPERATURE_PAGE,
  VOLUME1,
  VOLUME2,
  CONCENTRATION,
  SPEED,
  PRINT_CONFIRM,
  LOADING_PAGE,
  SYSTEM_STATUS,
  ERROR_PAGE
};

Page currentPage = WELCOME;

// ==================== POSITION TRACKING ====================
long arduino_pos1 = 0;
long arduino_pos2 = 0;

// ==================== SYSTEM CONFIGURATION ====================
struct SystemConfig {
  float ratio1 = 1.0f;
  float ratio2 = 1.0f;
  float syringe_vol1 = 10.0f;
  float syringe_vol2 = 10.0f;
  float extrude_vol1 = 1.0f;
  float extrude_speed = 2.0f;
  float dispensed1 = 0.0f;
  float dispensed2 = 0.0f;
  float remaining1 = 10.0f;
  float remaining2 = 10.0f;
  long prime_pos1 = LOAD_POSITION;
  long prime_pos2 = LOAD_POSITION;
} config;

// UI parameter storage
float selectedTemp = -1;
float selectedVol1 = -1;
float selectedVol2 = -1;
float selectedConc = -1;
float selectedSpeed = -1;
float tempSelection = -1;

// UI options
int tempOptions[] = {30, 32, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80};
int numTempOptions = 12;
int concOptions[] = {0, 25, 50, 75, 100};
int numConcOptions = 5;
int volOptions[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int numVolOptions = 10;
int speedOptions[] = {1, 2, 3, 4, 5};
int numSpeedOptions = 5;

bool lastTouchState = false;

// ==================== UTILITY FUNCTIONS ====================
inline long mlToSteps(float ml) {
  return (long)(ml * STEPS_PER_ML);
}

inline float stepsToMl(long steps) {
  return (float)steps / STEPS_PER_ML;
}

inline long mmsToStepsPerSec(float mm_per_s) {
  long steps_s = (long)(mm_per_s / MM_PER_STEP);
  return constrain(steps_s, 1, MAX_SPEED_STEPS_S);
}

inline long stepsPerSecToTicUnits(long steps_per_sec) {
  return steps_per_sec * 10000L;
}

// ==================== THERMISTOR FUNCTIONS ====================
void updateTemperatures() {
  for (int i = 0; i < numThermistors; i++) {
    int adcValue = analogRead(thermistorPins[i]);
    
    if (adcValue <= 0 || adcValue >= 1023) {
      currentTemperatures[i] = -999; // Error value
      continue;
    }
    
    float voltageRatio = (1023.0 / adcValue) - 1.0;
    float resistance = seriesResistor / voltageRatio;
    
    float steinhart = resistance / thermistorNominal;
    steinhart = log(steinhart);
    steinhart /= betaCoefficient;
    steinhart += 1.0 / (temperatureNominal + 273.15);
    steinhart = 1.0 / steinhart;
    steinhart -= 273.15;
    
    currentTemperatures[i] = steinhart;
  }
}

// ==================== POSITION SYNCHRONIZATION ====================
bool syncPositionToTIC() {
  tic1.haltAndSetPosition(arduino_pos1);
  tic2.haltAndSetPosition(arduino_pos2);
  delay(20);
  
  long verify1 = tic1.getCurrentPosition();
  long verify2 = tic2.getCurrentPosition();
  
  if (abs(verify1 - arduino_pos1) > 5 || abs(verify2 - arduino_pos2) > 5) {
    Serial.println("ERROR: TIC position sync failed!");
    return false;
  }
  return true;
}

// ==================== MOTOR CONTROL ====================
void initializeMotors() {
  Wire.begin();
  delay(100);
  
  Serial.println("Initializing motors via I2C...");
  
  tic1.setAddress(MOTOR1_ADDRESS);
  delay(10);
  tic1.clearDriverError();
  tic1.energize();
  delay(10);
  tic1.exitSafeStart();
  delay(10);
  tic1.setMaxAccel(MAX_ACCEL * 100L);
  tic1.setMaxDecel(MAX_ACCEL * 100L);
  
  tic2.setAddress(MOTOR2_ADDRESS);
  delay(10);
  tic2.clearDriverError();
  tic2.energize();
  delay(10);
  tic2.exitSafeStart();
  delay(10);
  tic2.setMaxAccel(MAX_ACCEL * 100L);
  tic2.setMaxDecel(MAX_ACCEL * 100L);
  
  Serial.println("Motors initialized");
  
  long init_pos1 = tic1.getCurrentPosition();
  long init_pos2 = tic2.getCurrentPosition();
  
  arduino_pos1 = init_pos1;
  arduino_pos2 = init_pos2;
  
  Serial.print("Initial positions: M1=");
  Serial.print(init_pos1);
  Serial.print(", M2=");
  Serial.println(init_pos2);
}

bool moveMotorsTo(long target1, long target2, float speed_mms) {
  Serial.println("--- MOVEMENT ---");
  Serial.print("From: M1=");
  Serial.print(arduino_pos1);
  Serial.print(", M2=");
  Serial.println(arduino_pos2);
  Serial.print("To: M1=");
  Serial.print(target1);
  Serial.print(", M2=");
  Serial.println(target2);
  
  if (!syncPositionToTIC()) {
    Serial.println("Cannot move - position sync failed");
    current_state = SAFE_MODE;
    return false;
  }
  
  tic1.clearDriverError();
  tic2.clearDriverError();
  tic1.exitSafeStart();
  tic2.exitSafeStart();
  
  long speed_steps = mmsToStepsPerSec(speed_mms);
  tic1.setMaxSpeed(stepsPerSecToTicUnits(speed_steps));
  tic2.setMaxSpeed(stepsPerSecToTicUnits(speed_steps));
  
  tic1.setTargetPosition(target1);
  tic2.setTargetPosition(target2);
  
  unsigned long start_time = millis();
  
  while (true) {
    tic1.resetCommandTimeout();
    tic2.resetCommandTimeout();
    
    long pos1 = tic1.getCurrentPosition();
    long pos2 = tic2.getCurrentPosition();
    
    uint16_t err1 = tic1.getErrorStatus();
    uint16_t err2 = tic2.getErrorStatus();
    
    if (err1 != 0 || err2 != 0) {
      Serial.println("Motor error during movement!");
      arduino_pos1 = pos1;
      arduino_pos2 = pos2;
      current_state = SAFE_MODE;
      return false;
    }
    
    bool arrived1 = abs(pos1 - target1) <= POSITION_TOLERANCE;
    bool arrived2 = abs(pos2 - target2) <= POSITION_TOLERANCE;
    
    if (arrived1 && arrived2) {
      arduino_pos1 = target1;
      arduino_pos2 = target2;
      Serial.println("Movement complete");
      return true;
    }
    
    if (millis() - start_time > 60000) {
      Serial.println("Movement timeout!");
      arduino_pos1 = pos1;
      arduino_pos2 = pos2;
      current_state = SAFE_MODE;
      return false;
    }
    
    delay(50);
  }
}

// ==================== MOTOR COMMANDS ====================
bool executeLoad() {
  if (current_state == SAFE_MODE) {
    return false;
  }
  
  Serial.println("=== LOAD STAGE ===");
  if (moveMotorsTo(LOAD_POSITION, LOAD_POSITION, 2.5f)) {
    current_state = LOAD;
    return true;
  }
  return false;
}

bool executeSetup(float vol1, float vol2, float conc) {
  if (current_state != LOAD && current_state != SETUP && current_state != PRIMED) {
    return false;
  }
  
  if (vol1 <= 0 || vol1 > 12 || vol2 <= 0 || vol2 > 12) {
    return false;
  }
  
  Serial.println("=== SETUP STAGE ===");
  
  // Convert concentration to ratio (conc is % of material 1)
  config.ratio1 = conc / 100.0f;
  config.ratio2 = (100.0f - conc) / 100.0f;
  config.syringe_vol1 = vol1;
  config.syringe_vol2 = vol2;
  config.remaining1 = vol1;
  config.remaining2 = vol2;
  config.dispensed1 = 0.0f;
  config.dispensed2 = 0.0f;
  
  Serial.print("Ratio: ");
  Serial.print(config.ratio1, 3);
  Serial.print(":");
  Serial.println(config.ratio2, 3);
  Serial.print("Volumes: M1=");
  Serial.print(vol1);
  Serial.print("mL, M2=");
  Serial.print(vol2);
  Serial.println("mL");
  
  current_state = SETUP;
  return true;
}

bool executePrime() {
  if (current_state != SETUP) {
    return false;
  }
  
  Serial.println("=== PRIME STAGE ===");
  
  float missing1 = MAX_VOLUME_ML - config.syringe_vol1;
  float missing2 = MAX_VOLUME_ML - config.syringe_vol2;
  
  config.prime_pos1 = LOAD_POSITION - mlToSteps(missing1);
  config.prime_pos2 = LOAD_POSITION - mlToSteps(missing2);
  
  if (moveMotorsTo(config.prime_pos1, config.prime_pos2, 2.0f)) {
    Serial.println("Purging 0.11mL from each motor...");
    long purge_steps = mlToSteps(0.11f);
    long purge_target1 = config.prime_pos1 - purge_steps;
    long purge_target2 = config.prime_pos2 - purge_steps;
    
    if (purge_target1 >= 0 && purge_target2 >= 0) {
      if (moveMotorsTo(purge_target1, purge_target2, 1.0f)) {
        config.prime_pos1 = purge_target1;
        config.prime_pos2 = purge_target2;
        config.remaining1 -= 0.11f;
        config.remaining2 -= 0.11f;
        current_state = PRIMED;
        return true;
      }
    }
  }
  return false;
}

bool executeExtrude(float vol1, float speed) {
  if (current_state != PRIMED && current_state != COMPLETE) {
    return false;
  }
  
  if (vol1 <= 0 || vol1 > config.remaining1) {
    return false;
  }
  
  if (speed < 0.1f || speed > MAX_SPEED_MMS) {
    return false;
  }
  
  float vol2 = vol1 * (config.ratio2 / config.ratio1);
  
  if (vol2 > config.remaining2) {
    return false;
  }
  
  Serial.println("=== EXTRUDE STAGE ===");
  Serial.print("Dispensing: M1=");
  Serial.print(vol1);
  Serial.print("mL, M2=");
  Serial.print(vol2);
  Serial.println("mL");
  
  float dist1 = vol1 * MM_PER_ML;
  float dist2 = vol2 * MM_PER_ML;
  float max_dist = max(dist1, dist2);
  float time = max_dist / speed;
  float speed1 = dist1 / time;
  float speed2 = dist2 / time;
  float avg_speed = (speed1 + speed2) / 2.0f;
  
  long target1 = arduino_pos1 - mlToSteps(vol1);
  long target2 = arduino_pos2 - mlToSteps(vol2);
  
  if (target1 < 0 || target2 < 0) {
    return false;
  }
  
  current_state = EXTRUDING;
  
  if (moveMotorsTo(target1, target2, avg_speed)) {
    config.dispensed1 += vol1;
    config.dispensed2 += vol2;
    config.remaining1 -= vol1;
    config.remaining2 -= vol2;
    current_state = COMPLETE;
    return true;
  }
  return false;
}

// ==================== UI DRAWING FUNCTIONS ====================
void drawWelcomePage() {
  display.fillScreen(BG_COLOR);
  display.setTextColor(TEXT_COLOR);
  
  display.setFont(&FreeSansBold18pt7b);
  display.setCursor(120, 300);
  display.print("BioPrint AM");
  
  display.setFont(&FreeSansBold12pt7b);
  display.setCursor(80, 380);
  display.print("Ready to start printing?");
  
  display.fillRoundRect(140, 450, 200, 80, 8, CONFIRM_COLOR);
  display.setFont(&FreeSansBold18pt7b);
  display.setTextColor(BUTTON_TEXT_COLOR);
  display.setCursor(190, 500);
  display.print("START");
}

void drawHomePage() {
  display.fillScreen(BG_COLOR);
  display.setTextColor(TEXT_COLOR);
  display.setFont(&FreeSansBold12pt7b);
  display.setCursor(35, 50);
  display.print("PARAMETER CONTROL");
  
  drawHomeButton(40, 120, "Temperature", selectedTemp, "C");
  drawHomeButton(40, 230, "Volume 1", selectedVol1, "mL");
  drawHomeButton(40, 340, "Volume 2", selectedVol2, "mL");
  drawHomeButton(40, 450, "Concentration", selectedConc, "%");
  drawHomeButton(40, 560, "Speed", selectedSpeed, "mm/s");
  
  display.fillRoundRect(140, 690, 200, 80, 8, CONFIRM_COLOR);
  display.setFont(&FreeSansBold18pt7b);
  display.setTextColor(TEXT_COLOR);
  display.setCursor(185, 740);
  display.print("PRINT");
}

void drawHomeButton(int x, int y, const char* label, float value, const char* unit) {
  display.fillRoundRect(x, y, 400, 90, 8, BUTTON_COLOR);
  
  display.setFont(&FreeSansBold12pt7b);
  display.setTextColor(BUTTON_TEXT_COLOR);
  display.setCursor(x + 15, y + 30);
  display.print(label);
  
  display.setFont(&FreeSans9pt7b);
  display.setCursor(x + 15, y + 65);
  if (value < 0) {
    display.print("Not Selected");
  } else {
    display.print("Selected: ");
    
    if (unit[0] == '%') {
      float inverse = 100 - value;
      display.print(value, 1);
      display.print(":");
      display.print(inverse, 1);
      display.print("%");
    } else {
      display.print(value, 1);
      display.print(" ");
      if (unit[0] == 'C') {
        display.write(248);
      }
      display.print(unit);
    }
  }
}

void drawParameterPage(const char* title, int* options, int numOptions, const char* unit) {
  display.fillScreen(BG_COLOR);
  display.setTextColor(TEXT_COLOR);
  display.setFont(&FreeSansBold12pt7b);
  display.setCursor(50, 40);
  display.print("Select ");
  display.print(title);
  display.print(":");
  
  int boxX = 40;
  int boxY = 75;
  int boxWidth = 260;
  int boxHeight = 100;
  int buttonSize = 70;
  int buttonSpacing = 10;
  
  // Minus button
  display.fillRoundRect(boxX, boxY, buttonSize, boxHeight, 8, CONFIRM_COLOR);
  display.setFont(&FreeSansBold18pt7b);
  display.setTextColor(BUTTON_TEXT_COLOR);
  display.setCursor(boxX + 28, boxY + 62);
  display.print("-");
  
  // Display box
  display.fillRoundRect(boxX + buttonSize + buttonSpacing, boxY, boxWidth, boxHeight, 8, BUTTON_COLOR);
  display.setFont(&FreeSansBold18pt7b);
  display.setTextColor(BUTTON_TEXT_COLOR);
  
  if (tempSelection < 0) {
    display.setCursor(boxX + buttonSize + buttonSpacing + 45, boxY + 62);
    display.print("Not Set");
  } else {
    String valueStr = "";
    
    if (unit[0] == '%') {
      float inverse = 100 - tempSelection;
      valueStr = String(tempSelection, 1) + ":" + String(inverse, 1) + "%";
      int charCount = valueStr.length();
      int textWidth = charCount * 18;
      int textX = boxX + buttonSize + buttonSpacing + (boxWidth / 2) - (textWidth / 2);
      display.setCursor(textX, boxY + 62);
      display.print(valueStr);
    } else if (unit[0] == 'C') {
      int charCount = String(tempSelection, 1).length() + 2;
      int textWidth = charCount * 18;
      int textX = boxX + buttonSize + buttonSpacing + (boxWidth / 2) - (textWidth / 2);
      display.setCursor(textX, boxY + 62);
      display.print(tempSelection, 1);
      display.print(" ");
      display.write(248);
      display.print(unit);
    } else {
      valueStr = String(tempSelection, 1) + " " + unit;
      int charCount = valueStr.length();
      int textWidth = charCount * 18;
      int textX = boxX + buttonSize + buttonSpacing + (boxWidth / 2) - (textWidth / 2);
      display.setCursor(textX, boxY + 62);
      display.print(valueStr);
    }
  }
  
  // Plus button
  display.fillRoundRect(boxX + buttonSize + buttonSpacing + boxWidth + buttonSpacing, boxY, buttonSize, boxHeight, 8, CONFIRM_COLOR);
  display.setFont(&FreeSansBold18pt7b);
  display.setTextColor(BUTTON_TEXT_COLOR);
  display.setCursor(boxX + buttonSize + buttonSpacing + boxWidth + buttonSpacing + 24, boxY + 62);
  display.print("+");
  
  // Option buttons
  int cols = 3;
  int buttonWidth = 120;
  int buttonHeight = 80;
  int spacingX = 20;
  int spacingY = 20;
  int startX = 40;
  int startY = 200;
  
  for (int i = 0; i < numOptions; i++) {
    int row = i / cols;
    int col = i % cols;
    int bx = startX + col * (buttonWidth + spacingX);
    int by = startY + row * (buttonHeight + spacingY);
    
    bool isSelected = (abs(options[i] - tempSelection) < 0.01);
    uint16_t bgColor = isSelected ? BUTTON_SELECTED_COLOR : BUTTON_COLOR;
    
    display.fillRoundRect(bx, by, buttonWidth, buttonHeight, 8, bgColor);
    display.setFont(&FreeSansBold18pt7b);
    display.setTextColor(BUTTON_TEXT_COLOR);
    
    String valueStr = String(options[i]);
    int charCount = valueStr.length();
    int textWidth = charCount * 20;
    int textX = bx + (buttonWidth - textWidth) / 2;
    int textY = by + 52;
    
    display.setCursor(textX, textY);
    display.print(options[i]);
  }
  
  // Clear button
  display.fillRoundRect(170, 630, 140, 50, 8, CLEAR_COLOR);
  display.setFont(&FreeSansBold12pt7b);
  display.setTextColor(BUTTON_TEXT_COLOR);
  display.setCursor(195, 663);
  display.print("CLEAR");
  
  // Confirm button
  display.fillRoundRect(140, 700, 200, 70, 8, CONFIRM_COLOR);
  display.setFont(&FreeSansBold12pt7b);
  display.setTextColor(BUTTON_TEXT_COLOR);
  display.setCursor(170, 745);
  display.print("CONFIRM");
}

void drawPrintConfirmPage() {
  display.fillScreen(BG_COLOR);
  display.setTextColor(TEXT_COLOR);
  display.setFont(&FreeSansBold18pt7b);
  display.setCursor(80, 50);
  display.print("Begin Loading?");
  
  int yPos = 130;
  int lineHeight = 90;
  
  drawParameterSummary(40, yPos, "Temperature:", selectedTemp, "C");
  yPos += lineHeight;
  drawParameterSummary(40, yPos, "Volume 1:", selectedVol1, "mL");
  yPos += lineHeight;
  drawParameterSummary(40, yPos, "Volume 2:", selectedVol2, "mL");
  yPos += lineHeight;
  drawParameterSummary(40, yPos, "Concentration:", selectedConc, "%");
  yPos += lineHeight;
  drawParameterSummary(40, yPos, "Speed:", selectedSpeed, "mm/s");
  
  display.fillRoundRect(60, 650, 160, 80, 8, CONFIRM_COLOR);
  display.setFont(&FreeSansBold12pt7b);
  display.setTextColor(BUTTON_TEXT_COLOR);
  display.setCursor(85, 700);
  display.print("CONFIRM");
  
  display.fillRoundRect(260, 650, 160, 80, 8, CANCEL_COLOR);
  display.setFont(&FreeSansBold12pt7b);
  display.setTextColor(BUTTON_TEXT_COLOR);
  display.setCursor(295, 700);
  display.print("CANCEL");
}

void drawParameterSummary(int x, int y, const char* label, float value, const char* unit) {
  display.setFont(&FreeSansBold12pt7b);
  display.setTextColor(TEXT_COLOR);
  display.setCursor(x, y);
  display.print(label);
  
  display.setFont(&FreeSansBold12pt7b);
  display.setCursor(x, y + 40);
  if (value < 0) {
    display.print("Not Selected");
  } else {
    if (unit[0] == '%') {
      float inverse = 100 - value;
      display.print(value, 1);
      display.print(":");
      display.print(inverse, 1);
      display.print("%");
    } else {
      display.print(value, 1);
      display.print(" ");
      if (unit[0] == 'C') {
        display.write(248);
      }
      display.print(unit);
    }
  }
}

void drawLoadingPage() {
  display.fillScreen(BG_COLOR);
  
  display.setFont(&FreeSansBold18pt7b);
  display.setTextColor(CONFIRM_COLOR);
  display.setCursor(130, 250);
  display.print("Loading...");
  
  // Show current state
  display.setFont(&FreeSansBold12pt7b);
  display.setTextColor(TEXT_COLOR);
  display.setCursor(100, 350);
  display.print("State: ");
  display.print(state_names[current_state]);
  
  // Show temperatures
  display.setCursor(80, 420);
  display.print("Temperatures:");
  for (int i = 0; i < numThermistors; i++) {
    display.setCursor(80, 450 + i * 30);
    display.print("T");
    display.print(i);
    display.print(": ");
    if (currentTemperatures[i] > -100) {
      display.print(currentTemperatures[i], 1);
      display.write(248);
      display.print("C");
    } else {
      display.print("Error");
    }
  }
  
  display.fillRoundRect(140, 680, 200, 80, 8, CONFIRM_COLOR);
  display.setFont(&FreeSansBold18pt7b);
  display.setTextColor(BUTTON_TEXT_COLOR);
  display.setCursor(195, 730);
  display.print("HOME");
}

void drawErrorPage(const char* errorMsg) {
  display.fillScreen(BG_COLOR);
  
  display.fillRoundRect(40, 250, 400, 150, 8, CANCEL_COLOR);
  display.setTextColor(TEXT_COLOR);
  display.setFont(&FreeSansBold12pt7b);
  
  display.setCursor(60, 300);
  display.print("Error:");
  display.setCursor(60, 340);
  display.print(errorMsg);
  
  display.fillRoundRect(165, 450, 150, 70, 8, BUTTON_COLOR);
  display.setFont(&FreeSansBold18pt7b);
  display.setTextColor(BUTTON_TEXT_COLOR);
  display.setCursor(210, 495);
  display.print("OK");
}

// ==================== TOUCH HANDLERS ====================
void handleWelcomeTouch(int x, int y) {
  if (x >= 140 && x <= 340 && y >= 450 && y <= 530) {
    Serial.println("START button pressed");
    currentPage = HOME;
    drawHomePage();
  }
}

void handleHomeTouch(int x, int y) {
  if (x >= 40 && x <= 440) {
    if (y >= 120 && y <= 210) {
      currentPage = TEMPERATURE_PAGE;
      tempSelection = selectedTemp;
      drawParameterPage("Temperature", tempOptions, numTempOptions, "C");
    } else if (y >= 230 && y <= 320) {
      currentPage = VOLUME1;
      tempSelection = selectedVol1;
      drawParameterPage("Volume 1", volOptions, numVolOptions, "mL");
    } else if (y >= 340 && y <= 430) {
      currentPage = VOLUME2;
      tempSelection = selectedVol2;
      drawParameterPage("Volume 2", volOptions, numVolOptions, "mL");
    } else if (y >= 450 && y <= 540) {
      currentPage = CONCENTRATION;
      tempSelection = selectedConc;
      drawParameterPage("Concentration", concOptions, numConcOptions, "%");
    } else if (y >= 560 && y <= 650) {
      currentPage = SPEED;
      tempSelection = selectedSpeed;
      drawParameterPage("Speed", speedOptions, numSpeedOptions, "mm/s");
    }
  }
  
  if (x >= 140 && x <= 340 && y >= 690 && y <= 770) {
    if (selectedTemp < 0 || selectedVol1 < 0 || selectedVol2 < 0 || 
        selectedConc < 0 || selectedSpeed < 0) {
      Serial.println("Error: Not all parameters selected");
      currentPage = ERROR_PAGE;
      drawErrorPage("Select all parameters");
    } else {
      Serial.println("All parameters selected");
      currentPage = PRINT_CONFIRM;
      drawPrintConfirmPage();
    }
  }
}

void handleParameterTouch(int x, int y, int* options, int numOptions, float* selectedParam) {
  int boxX = 40;
  int boxY = 75;
  int boxHeight = 100;
  int buttonSize = 70;
  int buttonSpacing = 10;
  int boxWidth = 260;
  
  float increment = 0.1;
  if (currentPage == CONCENTRATION) {
    increment = 0.5;
  }
  
  // Minus button
  if (x >= boxX && x <= (boxX + buttonSize) && y >= boxY && y <= (boxY + boxHeight)) {
    if (tempSelection < 0) {
      tempSelection = options[0];
    } else {
      tempSelection -= increment;
      if (tempSelection < 0) tempSelection = 0;
    }
    
    const char* title = "";
    const char* unit = "";
    getCurrentPageInfo(&title, &unit);
    drawParameterPage(title, options, numOptions, unit);
    return;
  }
  
  // Plus button
  int plusX = boxX + buttonSize + buttonSpacing + boxWidth + buttonSpacing;
  if (x >= plusX && x <= (plusX + buttonSize) && y >= boxY && y <= (boxY + boxHeight)) {
    if (tempSelection < 0) {
      tempSelection = options[0];
    } else {
      tempSelection += increment;
    }
    
    const char* title = "";
    const char* unit = "";
    getCurrentPageInfo(&title, &unit);
    drawParameterPage(title, options, numOptions, unit);
    return;
  }
  
  // Clear button
  if (x >= 170 && x <= 310 && y >= 630 && y <= 680) {
    tempSelection = -1;
    
    const char* title = "";
    const char* unit = "";
    getCurrentPageInfo(&title, &unit);
    drawParameterPage(title, options, numOptions, unit);
    return;
  }
  
  // Confirm button
  if (x >= 140 && x <= 340 && y >= 700 && y <= 770) {
    if (tempSelection >= 0) {
      *selectedParam = tempSelection;
    }
    currentPage = HOME;
    drawHomePage();
    return;
  }
  
  // Option buttons
  int cols = 3;
  int buttonWidth = 120;
  int buttonHeight = 80;
  int spacingX = 20;
  int spacingY = 20;
  int startX = 40;
  int startY = 200;
  
  for (int i = 0; i < numOptions; i++) {
    int row = i / cols;
    int col = i % cols;
    int bx = startX + col * (buttonWidth + spacingX);
    int by = startY + row * (buttonHeight + spacingY);
    
    if (x >= bx && x <= (bx + buttonWidth) && y >= by && y <= (by + buttonHeight)) {
      tempSelection = options[i];
      
      const char* title = "";
      const char* unit = "";
      getCurrentPageInfo(&title, &unit);
      drawParameterPage(title, options, numOptions, unit);
      break;
    }
  }
}

void handlePrintConfirmTouch(int x, int y) {
  if (x >= 60 && x <= 220 && y >= 650 && y <= 730) {
    Serial.println("Confirm - starting print sequence");
    
    // Execute the full sequence
    currentPage = LOADING_PAGE;
    drawLoadingPage();
    delay(500);
    
    // Step 1: Load motors
    if (!executeLoad()) {
      drawErrorPage("Load failed");
      currentPage = ERROR_PAGE;
      return;
    }
    drawLoadingPage();
    delay(500);
    
    // Step 2: Setup with selected parameters
    if (!executeSetup(selectedVol1, selectedVol2, selectedConc)) {
      drawErrorPage("Setup failed");
      currentPage = ERROR_PAGE;
      return;
    }
    drawLoadingPage();
    delay(500);
    
    // Step 3: Prime motors
    if (!executePrime()) {
      drawErrorPage("Prime failed");
      currentPage = ERROR_PAGE;
      return;
    }
    drawLoadingPage();
    delay(500);
    
    // Step 4: Execute extrusion
    // Use a small initial volume for testing, or customize as needed
    float extrudeVol = min(selectedVol1, 1.0f); // Extrude 1mL or less
    if (!executeExtrude(extrudeVol, selectedSpeed)) {
      drawErrorPage("Extrude failed");
      currentPage = ERROR_PAGE;
      return;
    }
    
    drawLoadingPage();
    Serial.println("Print sequence complete!");
  }
  
  if (x >= 260 && x <= 420 && y >= 650 && y <= 730) {
    Serial.println("Cancel button pressed");
    currentPage = HOME;
    drawHomePage();
  }
}

void handleLoadingTouch(int x, int y) {
  if (x >= 140 && x <= 340 && y >= 680 && y <= 760) {
    currentPage = HOME;
    drawHomePage();
  }
}

void handleErrorTouch(int x, int y) {
  if (x >= 165 && x <= 315 && y >= 450 && y <= 520) {
    currentPage = HOME;
    drawHomePage();
  }
}

void handleTouch(int x, int y) {
  switch (currentPage) {
    case WELCOME:
      handleWelcomeTouch(x, y);
      break;
    case HOME:
      handleHomeTouch(x, y);
      break;
    case TEMPERATURE_PAGE:
      handleParameterTouch(x, y, tempOptions, numTempOptions, &selectedTemp);
      break;
    case VOLUME1:
      handleParameterTouch(x, y, volOptions, numVolOptions, &selectedVol1);
      break;
    case VOLUME2:
      handleParameterTouch(x, y, volOptions, numVolOptions, &selectedVol2);
      break;
    case CONCENTRATION:
      handleParameterTouch(x, y, concOptions, numConcOptions, &selectedConc);
      break;
    case SPEED:
      handleParameterTouch(x, y, speedOptions, numSpeedOptions, &selectedSpeed);
      break;
    case PRINT_CONFIRM:
      handlePrintConfirmTouch(x, y);
      break;
    case LOADING_PAGE:
      handleLoadingTouch(x, y);
      break;
    case ERROR_PAGE:
      handleErrorTouch(x, y);
      break;
  }
}

void getCurrentPageInfo(const char** title, const char** unit) {
  if (currentPage == TEMPERATURE_PAGE) {
    *title = "Temperature";
    *unit = "C";
  } else if (currentPage == VOLUME1) {
    *title = "Volume 1";
    *unit = "mL";
  } else if (currentPage == VOLUME2) {
    *title = "Volume 2";
    *unit = "mL";
  } else if (currentPage == CONCENTRATION) {
    *title = "Concentration";
    *unit = "%";
  } else if (currentPage == SPEED) {
    *title = "Speed";
    *unit = "mm/s";
  }
}

// ==================== SETUP ====================
void setup() {
  Serial.begin(115200);
  while (!Serial && millis() < 3000);
  
  delay(1000);
  
  Serial.println("\n================================");
  Serial.println("  BIOPRINT AM - UNIFIED SYSTEM");
  Serial.println("================================");
  
  // Initialize display
  display.begin();
  touchDetector.begin();
  display.setRotation(0);
  display.fillScreen(BG_COLOR);
  
  // Initialize motors
  initializeMotors();
  
  // Initialize thermistors
  updateTemperatures();
  
  Serial.println("System ready!");
  
  drawWelcomePage();
}

// ==================== MAIN LOOP ====================
void loop() {
  // Update temperatures periodically
  if (millis() - lastTempUpdate > TEMP_UPDATE_INTERVAL) {
    updateTemperatures();
    lastTempUpdate = millis();
    
    // If on loading page, refresh to show updated temps
    if (currentPage == LOADING_PAGE) {
      drawLoadingPage();
    }
  }
  
  // Handle touch input
  uint8_t contacts;
  GDTpoint_t points[5];
  contacts = touchDetector.getTouchPoints(points);
  
  if (contacts > 0 && !lastTouchState) {
    int x = points[0].x;
    int y = points[0].y;
    
    Serial.print("Touch at X: ");
    Serial.print(x);
    Serial.print(" Y: ");
    Serial.println(y);
    
    handleTouch(x, y);
    lastTouchState = true;
    delay(250);
  } else if (contacts == 0) {
    lastTouchState = false;
  }
  
  // Keep motors responsive
  if (current_state == EXTRUDING) {
    tic1.resetCommandTimeout();
    tic2.resetCommandTimeout();
  }
  
  delay(10);
}
